<templateSet group="_VV_container__collection">
  <template name="map immutable" value="$l1$=( (1:&quot;a&quot;), (2:&quot;b&quot;), $END$)" description="NEW  tuple" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list enumerate ADD INDEX TO COLLECTION ELEMENTS" value="$l1$= enumerate($l$) $END$" description="NEW  coll with indexes" toReformat="false" toShortenFQNames="true">
    <variable name="l" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list immutable" value="$l1$=($END$)" description="NEW  tuple" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list immutableList-&gt;list" value="$s1$=list($s$)" description="NEW  tuple-&gt;list" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="s1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list list-&gt;immutableList" value="$s1$=tuple($s$)" description="NEW  list-&gt;tuple" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="s1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list mutable" value="$l1$=[$END$]" description="NEW  list" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list range" value="$l1$= range(5,-5,-1) $END$" description="NEW  range lazy" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map dict-&gt;immutableDict" value="$s1$=tuple($s$.items())" description="NEW  dict-&gt;tuple" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="s1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map immutableDict-&gt;dict" value="$s1$=dict($s$)" description="NEW  tuple-&gt;dict" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="s1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map mutable" value="$l1$={1:&quot;a&quot;, 2:&quot;b&quot;, $END$}" description="NEW  dict" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map mutable stringkeys" value="$l1$={uno=&quot;one&quot;,dos=&quot;two&quot; $END$}" description="NEW  dict(uno=&quot;one&quot;)" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="namedtuple temp" value="def ntuple(**params):&#10;    return namedtuple(&quot;NT&quot;,sorted(dn := dict(params) ))(**dn)&#10;&#10;tn2=ntuple(odin=1,dva=2)&#10;print(tn2)&#10;$END$" description="NEW  ntuple(odin=1,dva=2)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="namedtuple dict -&gt; namedtuple" value="dn=dict(uno=1,dos=2) $END$&#10;print(&quot;DICT1 &quot;,dn)&#10;tn=namedtuple(&quot;VO&quot;,sorted(dn))(**dn)&#10;print(&quot;DICT2 &quot;, tn )" description="NEW  namedtuple" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="namedtuple namedtuple -&gt; dict" value="tn._asdict()&#10;$END$" description="NEW  namedtuple._asdict" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set immutable" value="$l1$=frozenset($list$)&#10;$END$" description="NEW  frozenset" toReformat="false" toShortenFQNames="true">
    <variable name="list" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set immutableSet-&gt;set" value="$s1$=set($s$)" description="NEW  frozenset-&gt;set" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="s1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set mutable" value="$l1$=set($END$)" description="NEW  set" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set set-&gt;immutableSet" value="$s1$=frozenset($s$)" description="NEW  set-&gt;frozenset" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="s1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list-&gt;str" value="print(&quot; &quot;.join(map(str,arr)))&#10;#print(&quot; &quot;.join(str(i) for i in arr))" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list pattern matching 1" value="a,b,c,d=&quot;abcd&quot;&#10;aa,*bcd=&quot;abcd&quot;&#10;# распаковка всегда дает list&#10;# если элементов меньше то *bcd будет []&#10;#a,b,c,d={4: &quot;a&quot;, 3: &quot;c&quot;, 2: &quot;b&quot;, 1: &quot;d&quot; }&#10;#aa,*bcd={4: &quot;a&quot;, 3: &quot;c&quot;, 2: &quot;b&quot;, 1: &quot;d&quot; }&#10;print(a,b,c,d,aa,bcd)&#10;&#10;&#10;&#10;lt=[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]&#10;for [x,y,z] in lt:&#10;    print(&quot;LIST3&quot;,x,y,z)&#10;$END$    " description="my pattern matching list [x,y,z]" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list pattern matching2 laHaskell" value="lt=[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]&#10;for [x,*xs] in lt:&#10;    print(&quot;LIST3&quot;,x,xs)&#10;$END$    " description="my pattern matching list [x,xs]" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list copy shallow" value="$copy$=$l$[:]" description="NEW  list[:]" toReformat="false" toShortenFQNames="true">
    <variable name="l" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="copy" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list copy deep" value="from copy import *&#10;$copy$=deepcopy($l$)&#10;" description="NEW  deepcopy(list)" toReformat="false" toShortenFQNames="true">
    <variable name="l" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="copy" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="namedtuple immutable class (short)" value="Car = namedtuple('Car', 'attr1 attr2')&#10;#Car = namedtuple('Car', ['attr1', 'attr2'])&#10;car=Car(1,2)&#10;print(car)&#10;$END$" description="NEW  namedtuple()" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list deduplicate elements" value="$l1$=set($list$)&#10;$END$" description="NEW  set" toReformat="false" toShortenFQNames="true">
    <variable name="list" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list SWAP elements in list" value="def swap(i, j):&#10;    $arr$[i], $arr$[j] = $arr$[j], $arr$[i]" description="" toReformat="false" toShortenFQNames="true">
    <variable name="arr" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map get first key" value="next(iter($s$))" description="next(iter)" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list QUEUE" value="queue_=[]&#10;queue_[:0] = [12]   # push&#10;v = queue_.pop()    # pop" description="NEW  []" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list STACK" value="stack_=[]&#10;stack_+=[vertex] # push&#10;obj = stack_.pop() # pop" description="NEW  []" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map WITH DEFAULT  VALUES" value="# все создаваемые entry будут иметь value по-умолчанию (например -массив )&#10;# !! предостережение - каждое получение ненайденного элемента создает его &#10;dd=defaultdict(list) &#10;dd=defaultdict(lambda: []) &#10;dd[1]+=[1,2]&#10;print(dd)" description="defaultdict( all default values=[] )" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list HEAP" value="heap_=[]&#10;heappush(heap_, (5, 'write code'))&#10;obj =  heappop(heap_)     # pop возвращает наименьший элемент&#10;obj = heap_[0]             # это самый маленький элемент, без удаления &#10; &#10;# heapify(list) - сам список будет МУТИРОВАН!!" description="NEW  [] priority queue" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list HEAPQ with class for entry 2" value="class Entry():&#10;    def __init__(self, key, value):&#10;        self.key = key&#10;        self.value = value&#10;&#10;    def __lt__(self, other):&#10;        return self.value &lt; other.value&#10;&#10;    def __repr__(self):&#10;        return f&quot;{self.key}-{self.value}&quot;&#10;&#10;&#10;heap, heap_dict = [], {}&#10;&#10;&#10;def push(key, value):&#10;    entry = Entry(value, key)  # ordering element goes first&#10;    heappush(heap, entry)&#10;    heap_dict[key] = entry&#10;&#10;def pop(): return heappop(heap)&#10;&#10;push(5, 10)&#10;push(6, 9)&#10;print(&quot;heap=&quot;, heap)&#10;print(&quot;heap=&quot;, pop())" description="NEW  [class sorted by value]  {class hashed by key}" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set intersect" value="$l1$=$list$&amp;$list2$&#10;$END$" description="{a,b}&amp;{c,d}  только элементы которые есть в обоих множествах" toReformat="false" toShortenFQNames="true">
    <variable name="list" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="list2" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set MINUS" value="$l1$=$list$-$list2$&#10;$END$" description="{a,b}-{c,d}  вычесть из одного мнодества другое" toReformat="false" toShortenFQNames="true">
    <variable name="list" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="list2" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list HEAPmyclass with deletion operation" value="#from heapq import *&#10;&#10;class Heap():&#10;    &quot;&quot;&quot; Heap - priority queue.&#10;&#10;    Each element is a tuple (key,value)&#10;    &quot;&quot;&quot;&#10;&#10;    REMOVED = '&lt;removed-task&gt;'  # placeholder for a removed task&#10;&#10;    def __init__(self, list_):  # type: (Heap, Iterable) -&gt; None&#10;        self.heap = list(list_) if list_ else []  # list of entries arranged in a heap&#10;        self.entry_finder = {e[1]: e for e in self.heap}  # mapping of VALUES to entries&#10;        heapify(self.heap)&#10;&#10;    def push(self, key, value):  # type: (Heap, Any, Hashable) -&gt; None&#10;        &quot;&quot;&quot;Add a new VALUE or update the priority of an existing entry&quot;&quot;&quot;&#10;        if value in self.entry_finder:&#10;            self.remove(value)&#10;        entry = [key, value]&#10;        self.entry_finder[value] = entry&#10;        heappush(self.heap, entry)&#10;&#10;    def remove(self, value):  # type: (Heap, Hashable) -&gt; None&#10;        &quot;&quot;&quot;Mark an existing VALUE as REMOVED.  Raise KeyError if not found.&quot;&quot;&quot;&#10;        entry = self.entry_finder.pop(value)&#10;        entry[-1] = Heap.REMOVED&#10;&#10;    def find_entry(self, value):  # type: (Heap, Hashable) -&gt; Any&#10;        &quot;&quot;&quot; find entry by value &quot;&quot;&quot;&#10;        return self.entry_finder[value]&#10;&#10;    def peek(self):  # type: (Heap) -&gt; Any&#10;        &quot;&quot;&quot; peek first element &quot;&quot;&quot;&#10;        return self.heap[0]&#10;&#10;    def pop(self):  # type: (Heap) -&gt; Optional[Any]&#10;        &quot;&quot;&quot;Remove and return the lowest priority VALUE. Raise KeyError if empty.&quot;&quot;&quot;&#10;        while self.heap:&#10;            _, value = heappop(self.heap)&#10;            if value is not Heap.REMOVED:&#10;                del self.entry_finder[value]  # так как это операция pop то удалим также из словаря&#10;                return value&#10;        return None&#10;&#10;    def __repr__(self):&#10;        return f&quot;heap={self.heap} \n dict={self.entry_finder}&quot;" description="NEW  [class sorted by value]  {class hashed by key}" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list QUEUE PRIORITY CONCURRENT" value="from queue import PriorityQueue&#10;pq = PriorityQueue()&#10;pq.put(10)&#10;pq.put(9)&#10;pq.put(8)&#10;&#10;print(&quot;priority queue&quot;,pq.get())" description="standart queue.PriorityQueue" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list HEAPQ with class for entry 1" value="from dataclasses import dataclass, field&#10;&#10;@dataclass(order=True)&#10;class Entry():&#10;    key: int&#10;    value: Any = field(compare=False)&#10;&#10;heap, heap_dict = [], {}&#10;&#10;def push(key, value):&#10;    entry = Entry(key, value)  # ordering element goes first&#10;    heappush(heap, entry)&#10;    heap_dict[key] = entry&#10;&#10;def pop(): return heappop(heap)&#10;&#10;push(5, 10)&#10;push(6, 9)&#10;print(&quot;heap=&quot;, heap)&#10;print(&quot;heap=&quot;, pop())" description="use @dataclass annotation" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list new list of lists [ [] ]" value="len_x,len_y=10,5&#10;cols = [[0] * len_y for _ in range(len_x)]&#10;&#10;&quot;&quot;&quot;&#10;вложенные [ for for ]  запрещены&#10;&#10;table_vesi = [[[] for _ in range(len(vesi) + 1)] for _ in range(bagpack_capasity + 1)]&#10;    &#10;l = len(graph)&#10;table_vesi = [[inf for _ in range(l)] for _ in range(l)]&#10;&quot;&quot;&quot;" description="[ [for_in] for_in ]" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new DICT of DICTs" value="result = defaultdict(lambda:defaultdict(lambda:inf))&#10;parents = defaultdict(lambda:defaultdict(lambda:None))&#10;# !! предостережение - каждое получение ненайденного элемента создает его " description="defaultdict(defaultdict)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set intersect (super)" value="range_ = set(range(len(pts))) &amp; set(range(idx - 3, idx + 5)) - {idx}&#10;pts_d = map(pts.__getitem__, range_)&#10;&#10;    &#10;# take 4 left points, if possible&#10;cnt = 4&#10;while (cnt := cnt - 1) &gt;= 0 and idx1 &gt; 0:&#10;    idx1 -= 1&#10;&#10;# take 4 right points, if possible&#10;cnt = 4&#10;while (cnt := cnt - 1) &gt;= 0 and idx2 &lt; len(pts) - 1:&#10;    idx2 += 1&#10;pts_delta = pts[idx1: idx] + pts[idx + 1:idx2 + 1]" description="set(range(len(pts))) &amp; set(range(idx - 3, idx + 5))   вместо инкрементальных приращений индекса" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE самописка" value="cache = {}&#10;def someproc(val1,val2):&#10;    if seen := cache.get((val1, val2)): return seen&#10;    #get result&#10;    cache[(val1, val2)] = result&#10;    return result&#10;&#10; " description="f seen := cache.get((val1, val2)): return seen" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE SUPER" value="@functools.lru_cache&#10;&#10; " description="@functools.lru_cache" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
</templateSet>