<templateSet group="_VV_container__collection">
  <template name="map immutable" value="$l1$=( (1:&quot;a&quot;), (2:&quot;b&quot;), $END$)" description="NEW  tuple" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list enumerate ADD INDEX TO COLLECTION ELEMENTS" value="$l1$= enumerate($l$) $END$" description="NEW  coll with indexes" toReformat="false" toShortenFQNames="true">
    <variable name="l" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list immutable" value="$l1$=($END$)" description="NEW  tuple" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list immutableList-&gt;list" value="$s1$=list($s$)" description="NEW  tuple-&gt;list" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="s1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list list-&gt;immutableList" value="$s1$=tuple($s$)" description="NEW  list-&gt;tuple" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="s1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list mutable" value="$l1$=[$END$]" description="NEW  list" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list range [start, stop) step" value="$l1$= range(5,-5,-1) $END$" description="NEW  range lazy" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map dict-&gt;immutableDict" value="$s1$=tuple($s$.items())" description="NEW  dict-&gt;tuple" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="s1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map immutableDict-&gt;dict" value="$s1$=dict($s$)" description="NEW  tuple-&gt;dict" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="s1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map mutable" value="$l1$={1:&quot;a&quot;, 2:&quot;b&quot;, $END$}" description="NEW  dict" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map mutable stringkeys" value="$l1$={uno=&quot;one&quot;,dos=&quot;two&quot; $END$}" description="NEW  dict(uno=&quot;one&quot;)" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="namedtuple temp" value="def ntuple(**params):&#10;    return collections.namedtuple(&quot;NT&quot;,sorted(dn := dict(params) ))(**dn)&#10;&#10;tn2=ntuple(odin=1,dva=2)&#10;print(tn2)&#10;$END$" description="NEW  ntuple(odin=1,dva=2)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="namedtuple dict -&gt; namedtuple" value="dn=dict(uno=1,dos=2) $END$&#10;print(&quot;DICT1 &quot;,dn)&#10;tn= collections.namedtuple(&quot;VO&quot;,sorted(dn))(**dn)&#10;print(&quot;DICT2 &quot;, tn )" description="NEW  namedtuple" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="namedtuple namedtuple -&gt; dict" value="tn._asdict()&#10;$END$" description="NEW  namedtuple._asdict" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set immutable" value="$l1$=frozenset($list$)&#10;$END$" description="NEW  frozenset" toReformat="false" toShortenFQNames="true">
    <variable name="list" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set immutableSet-&gt;set" value="$s1$=set($s$)" description="NEW  frozenset-&gt;set" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="s1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set mutable" value="$l1$=set($END$)" description="NEW  set" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set set-&gt;immutableSet" value="$s1$=frozenset($s$)" description="NEW  set-&gt;frozenset" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="s1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list-&gt;str" value="print(&quot; &quot;.join(map(str,arr)))&#10;#print(&quot; &quot;.join(str(i) for i in arr))" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list pattern matching 1" value="a,b,c,d=&quot;abcd&quot;&#10;aa,*bcd=&quot;abcd&quot;&#10;# распаковка всегда дает list&#10;# если элементов меньше то *bcd будет []&#10;#a,b,c,d={4: &quot;a&quot;, 3: &quot;c&quot;, 2: &quot;b&quot;, 1: &quot;d&quot; }&#10;#aa,*bcd={4: &quot;a&quot;, 3: &quot;c&quot;, 2: &quot;b&quot;, 1: &quot;d&quot; }&#10;print(a,b,c,d,aa,bcd)&#10;&#10;&#10;&#10;lt=[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]&#10;for [x,y,z] in lt:&#10;    print(&quot;LIST3&quot;,x,y,z)&#10;$END$    " description="my pattern matching list [x,y,z]" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list pattern matching2 laHaskell" value="lt=[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]&#10;for [x,*xs] in lt:&#10;    print(&quot;LIST3&quot;,x,xs)&#10;$END$    " description="my pattern matching list [x,xs]" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list copy shallow" value="$copy$=$l$[:]" description="NEW  list[:]" toReformat="false" toShortenFQNames="true">
    <variable name="l" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="copy" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list copy deep" value="$copy$=copy.deepcopy($l$)&#10;" description="NEW  deepcopy(list)" toReformat="false" toShortenFQNames="true">
    <variable name="l" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="copy" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="namedtuple immutable class (short)" value="Car =  collections.namedtuple('Car', 'attr1 attr2')&#10;#Car = collections.namedtuple('Car', ['attr1', 'attr2'])&#10;car=Car(1,2)&#10;print(car)&#10;$END$" description="NEW  namedtuple()" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list deduplicate elements" value="$l1$=set($list$)&#10;$END$" description="NEW  set" toReformat="false" toShortenFQNames="true">
    <variable name="list" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list SWAP elements in list" value="def swap(i, j):&#10;    $arr$[i], $arr$[j] = $arr$[j], $arr$[i]" description="" toReformat="false" toShortenFQNames="true">
    <variable name="arr" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map get first key" value="next(iter($s$))" description="next(iter)" toReformat="false" toShortenFQNames="true">
    <variable name="s" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list QUEUE BAD" value="queue_=[]&#10;queue_[:0] = [12]   # push=enque&#10;v = queue_.pop()    # pop =deque" description="NEW  []" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list STACK" value="stack=[]&#10;stack+=[vertex] # push&#10;obj = stack.pop() # pop" description="NEW  []" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map WITH DEFAULT  VALUES" value="# все создаваемые entry будут иметь value по-умолчанию (например -массив )&#10;# !! предостережение - каждое получение ненайденного элемента создает его &#10;dd=collections.defaultdict(list) &#10;dd=collections.defaultdict(lambda: []) &#10;dd[1]+=[1,2]&#10;print(dd)" description="defaultdict( all default values=[] )" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list HEAP how to use" value="heap=[]&#10;heapq.heappush(heap, (5, 'write code'))&#10;obj =  heapq.heappop(heap)     # pop возвращает наименьший элемент&#10;obj = heap[0]             # это самый маленький элемент, без удаления &#10; &#10;# heapq.heapify(list) - сам список будет МУТИРОВАН!!" description="NEW  [] priority queue" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list HEAPQ with class for entry 2" value="class Entry():&#10;    def __init__(self, key, value):&#10;        self.key = key&#10;        self.value = value&#10;&#10;    def __lt__(self, other):&#10;        return self.value &lt; other.value&#10;&#10;    def __repr__(self):&#10;        return f&quot;{self.key}-{self.value}&quot;&#10;&#10;&#10;heap, heap_dict = [], {}&#10;&#10;&#10;def push(key, value):&#10;    entry = Entry(value, key)  # ordering element goes first&#10;    heapq.heappush(heap, entry)&#10;    heap_dict[key] = entry&#10;&#10;def pop(): return heapq.heappop(heap)&#10;&#10;push(5, 10)&#10;push(6, 9)&#10;print(&quot;heap=&quot;, heap)&#10;print(&quot;heap=&quot;, pop())" description="NEW  [class sorted by value]  {class hashed by key}" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set intersect" value="$l1$=$list$&amp;$list2$&#10;$END$" description="{a,b}&amp;{c,d}  только элементы которые есть в обоих множествах" toReformat="false" toShortenFQNames="true">
    <variable name="list" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="list2" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set MINUS" value="$l1$=$list$-$list2$&#10;$END$" description="{a,b}-{c,d}  вычесть из одного мнодества другое" toReformat="false" toShortenFQNames="true">
    <variable name="list" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="list2" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="l1" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list HEAP SUPER with deletion operation" value="class Heap():&#10;    &quot;&quot;&quot; Heap - priority queue.&#10;&#10;    Each element is a tuple (key,value)&#10;    &quot;&quot;&quot;&#10;&#10;    REMOVED = '&lt;removed-task&gt;'  # placeholder for a removed task&#10;&#10;    def __init__(self, list_):  # type: (Heap, Iterable) -&gt; None&#10;        self.heap = list(list_) if list_ else []  # list of entries arranged in a heap&#10;        self.entry_finder = {e[1]: e for e in self.heap}  # mapping of VALUES to entries&#10;        heapq.heapify(self.heap)&#10;&#10;    def push(self, key, value):  # type: (Heap, Any, Hashable) -&gt; None&#10;        &quot;&quot;&quot;Add a new VALUE or update the priority of an existing entry&quot;&quot;&quot;&#10;        if value in self.entry_finder:&#10;            self.remove(value)&#10;        entry = [key, value]&#10;        self.entry_finder[value] = entry&#10;        heapq.heappush(self.heap, entry)&#10;&#10;    def remove(self, value):  # type: (Heap, Hashable) -&gt; None&#10;        &quot;&quot;&quot;Mark an existing VALUE as REMOVED.  Raise KeyError if not found.&quot;&quot;&quot;&#10;        entry = self.entry_finder.pop(value)&#10;        entry[-1] = Heap.REMOVED&#10;&#10;    def find_entry(self, value):  # type: (Heap, Hashable) -&gt; Any&#10;        &quot;&quot;&quot; find entry by value &quot;&quot;&quot;&#10;        return self.entry_finder[value]&#10;&#10;    def peek(self):  # type: (Heap) -&gt; Any&#10;        &quot;&quot;&quot; peek first element &quot;&quot;&quot;&#10;        return self.heap[0]&#10;&#10;    def pop(self):  # type: (Heap) -&gt; Optional[Any]&#10;        &quot;&quot;&quot;Remove and return the lowest priority VALUE. Raise KeyError if empty.&quot;&quot;&quot;&#10;        while self.heap:&#10;            _, value = heapq.heappop(self.heap)&#10;            if value is not Heap.REMOVED:&#10;                del self.entry_finder[value]  # так как это операция pop то удалим также из словаря&#10;                return value&#10;        return None&#10;&#10;    def __repr__(self):&#10;        return f&quot;heap={self.heap} \n dict={self.entry_finder}&quot;" description="NEW  [class sorted by value]  {class hashed by key}" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list QUEUE PRIORITY CONCURRENT blocking" value="import queue # SimpleQueue PriorityQueue LifoQueue &#10;&#10;# то же самое что и heapq но только многопоточное&#10;# можно сделать заданного размера, и тогда очередь заблокируется при полном заполнении&#10;pq = queue.PriorityQueue()&#10;pq.put(10)&#10;pq.put(9)&#10;pq.put(8)&#10;&#10;print(&quot;priority queue&quot;,pq.get())" description="standart queue.PriorityQueue" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list HEAPQ with class for entry 1" value="from dataclasses import dataclass, field&#10;&#10;@dataclasses.dataclass(order=True)&#10;class Entry():&#10;    key: int&#10;    value: Any = dataclasses.field(compare=False)&#10;&#10;heap, heap_dict = [], {}&#10;&#10;def push(key, value):&#10;    entry = Entry(key, value)  # ordering element goes first&#10;    heapq.heappush(heap, entry)&#10;    heap_dict[key] = entry&#10;&#10;def pop(): return heapq.heappop(heap)&#10;&#10;push(5, 10)&#10;push(6, 9)&#10;print(&quot;heap=&quot;, heap)&#10;print(&quot;heap=&quot;, pop())" description="use @dataclass annotation" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new DICT of DICTs" value="result = collections.defaultdict(lambda:collections.defaultdict(lambda:inf))&#10;parents = collections.defaultdict(lambda:collections.defaultdict(lambda:None))&#10;# !! предостережение - каждое получение ненайденного элемента создает его " description="defaultdict(defaultdict)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="set intersect (super)" value="range_ = set(range(len(pts))) &amp; set(range(idx - 3, idx + 5)) - {idx}&#10;pts_d = map(pts.__getitem__, range_)&#10;# как вариант functools.partial(operator.getitem, arr)&#10; &#10;    &#10;# take 4 left points, if possible&#10;cnt = 4&#10;while (cnt := cnt - 1) &gt;= 0 and idx1 &gt; 0:&#10;    idx1 -= 1&#10;&#10;# take 4 right points, if possible&#10;cnt = 4&#10;while (cnt := cnt - 1) &gt;= 0 and idx2 &lt; len(pts) - 1:&#10;    idx2 += 1&#10;pts_delta = pts[idx1: idx] + pts[idx + 1:idx2 + 1]" description="set(range(len(pts))) &amp; set(range(idx - 3, idx + 5))   вместо инкрементальных приращений индекса" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE самописка" value="cache = {}&#10;def someproc(val1,val2):&#10;    if seen := cache.get((val1, val2)): return seen&#10;    #get result&#10;    cache[(val1, val2)] = result&#10;    return result&#10;&#10; " description="f seen := cache.get((val1, val2)): return seen" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE SUPER" value="@functools.lru_cache&#10;&#10; " description="@functools.lru_cache" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list range в обратном порядке по массиву" value="range(N-1,-1,-1)" description="range(N-1,-1,-1)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map mutable-&gt;immutable" value="tuple($l1$.items())" description="tuple(map.items())" toReformat="false" toShortenFQNames="true">
    <variable name="l1" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list QUEUE FIXEDSIZE с вытеснением" value="queue_=[]&#10;queue_[:0] = [12]   # push=enque&#10;v = queue_.pop()    # pop =deque&#10;&#10;dec = collections.deque([1, 2, 3, 4, 5, 6], maxlen=6)&#10;dec.appendleft(101)  # если добавить слева то вытеснится справа&#10;# [101, 1, 2, 3, 4, 5]&#10;dec.append(102) # если добавить справа то вытеснится слева&#10;# [1, 2, 3, 4, 5, 102]" description="deque(maxlen)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list QUEUE" value="queue =collections.deque()&#10;queue.append(12)   # push=enque&#10;v = queue.pop()    # pop =deque" description="NEW  []" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map STACK" value="map = {&#10;    1: 1,&#10;    2: 2,&#10;    3: 3,&#10;    4: 4&#10;}&#10;map1 = collections.OrderedDict(map)&#10;print(map1.popitem())  # LIFO queue&#10;print(map1.popitem(last=False))  # FIFO stacke" description="OrderedDict(map)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE LU last updated" value="class LastUpdatedOrderedDict(collections.OrderedDict):&#10;    &quot;&quot;&quot; Store items in the order the keys were last added &quot;&quot;&quot;&#10;&#10;    def __setitem__(self, key, value):&#10;        super().__setitem__(key, value)&#10;        self.move_to_end(key)&#10;&#10; " description="OrderedDict" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE  LRU Least recently used FIXEDSIZE" value="class LRU(collections.OrderedDict):&#10;    &quot;&quot;&quot; Limit size, evicting the least recently looked-up key when full &quot;&quot;&quot;&#10;&#10;    def __init__(self, maxsize=128, /, *args, **kwds):&#10;        self.maxsize = maxsize&#10;        super().__init__(*args, **kwds)&#10;&#10;    def __getitem__(self, key):&#10;        value = super().__getitem__(key)&#10;        self.move_to_end(key)&#10;        return value&#10;&#10;    def __setitem__(self, key, value):&#10;        super().__setitem__(key, value)&#10;        if len(self) &gt; self.maxsize:&#10;            oldest = next(iter(self))&#10;            del self[oldest]&#10;&#10; " description="OrderedDict  размер кэша можно ограничить" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list range в обратном порядке по массиву SUPER" value="reversed(range(N))" description="reversed(range(N))" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new COUNTER" value="counter_map = collections.Counter(nums)" description="collections.Counter(nums)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new from list with indexes" value="$che$ = {key: idx for idx, key in enumerate($nums$)}&#10;&#10; " description="{ key:idx }" toReformat="false" toShortenFQNames="true">
    <variable name="nums" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="che" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new COUNTER find duplicated elements" value="list_dups = [num for num, cnt in $collections$.Counter(nums).items() if cnt &gt; 1]" description="[ Counter(nums)  if cnt &gt; 1]" toReformat="false" toShortenFQNames="true">
    <variable name="collections" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE FIXEDSIZE LIFOqueue" value="class FixedSizeDict(collections.OrderedDict):&#10;    &quot;&quot;&quot; Limit size, evicting the LIFOqueue key when full &quot;&quot;&quot;&#10;&#10;    def __init__(self, maxsize=128, /, *args, **kwds):&#10;        self.maxsize = maxsize&#10;        super().__init__(*args, **kwds)&#10;&#10;    def __setitem__(self, key, value):&#10;        super().__setitem__(key, value)&#10;        if len(self) &gt; self.maxsize:&#10;            oldest = next(iter(self))&#10;            del self[oldest]&#10;&#10; " description="OrderedDict  размер кэша можно ограничить" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
</templateSet>