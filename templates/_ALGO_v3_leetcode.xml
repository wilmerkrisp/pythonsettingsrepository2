<templateSet group="_ALGO_v3_leetcode">
  <template name="map new list+dict. RandomizedSet" value="class RandomizedSet(object):&#10;    &quot;&quot;&quot; structure which provides the following operations in average O(1)  time: Insert Delete GetRandom&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        &quot;&quot;&quot; Initialize your data structure here.&#10;&#10;        -  list and dictionary for the same items are supported at the same time&#10;        -  aka indexed dictionary&#10;        &quot;&quot;&quot;&#10;        self.list = []&#10;        self.dict = {}&#10;&#10;    def insert(self, val: int) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Inserts a value to the set. Returns true if the set did not already contain the specified element.&#10;        &quot;&quot;&quot;&#10;        if val in self.dict:&#10;            return False&#10;&#10;        self.dict[val] = len(self.list)&#10;        self.list += [val]&#10;        return True&#10;&#10;    def remove(self, val: int) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Removes a value from the set. Returns true if the set contained the specified element.&#10;        &quot;&quot;&quot;&#10;        if (idx := self.dict.get(val)) is None:&#10;            return False&#10;&#10;        # swap last and deleted element&#10;        def swap(i, j):&#10;            self.list[i], self.list[j] = self.list[j], self.list[i]&#10;&#10;        swap(idx, -1)&#10;        self.dict[self.list[idx]] = idx&#10;&#10;        # delete from the end&#10;        self.list.pop()&#10;        del self.dict[val]&#10;        return True&#10;&#10;    def get_random(self) -&gt; int:&#10;        &quot;&quot;&quot;&#10;        Get a random element from the set.&#10;        &quot;&quot;&quot;&#10;        return random.choice(self.list)" description="O(1) inserte delete getRandom" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new COUNTER find duplicated elements" value="list_dups = [num for num, cnt in $collections$.Counter(nums).items() if cnt &gt; 1]" description="[ Counter(nums)  if cnt &gt; 1]" toReformat="false" toShortenFQNames="true">
    <variable name="collections" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE LU last updated" value="class LastUpdatedOrderedDict(collections.OrderedDict):&#10;    &quot;&quot;&quot; Store items in the order the keys were last added &quot;&quot;&quot;&#10;&#10;    def __setitem__(self, key, value):&#10;        super().__setitem__(key, value)&#10;        self.move_to_end(key)&#10;&#10; " description="OrderedDict" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE FIXEDSIZE LIFO stack" value="class FixedSizeDict(collections.OrderedDict):&#10;    &quot;&quot;&quot; Limit size, evicting the LIFOqueue key when full &quot;&quot;&quot;&#10;&#10;    def __init__(self, maxsize=128, /, *args, **kwds):&#10;        self.maxsize = maxsize&#10;        super().__init__(*args, **kwds)&#10;&#10;    def __setitem__(self, key, value):&#10;        super().__setitem__(key, value)&#10;        if len(self) &gt; self.maxsize:&#10;            self.popitem(last=False)&#10;            &#10;#        if len(self) &gt; self.maxsize:&#10;#            oldest = next(iter(self))&#10;#            del self[oldest]&#10;&#10; " description="OrderedDict  размер кэша можно ограничить" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE  LRU Least recently used FIXEDSIZE bad" value="class LRU(collections.OrderedDict):&#10;    &quot;&quot;&quot; Limit size, evicting the least recently looked-up key when full &quot;&quot;&quot;&#10;&#10;    def __init__(self, maxsize=128, /, *args, **kwds):&#10;        self.maxsize = maxsize&#10;        super().__init__(*args, **kwds)&#10;&#10;    def __getitem__(self, key):&#10;        value = super().__getitem__(key)&#10;        self.move_to_end(key)&#10;        return value&#10;&#10;    def __setitem__(self, key, value):&#10;        super().__setitem__(key, value)&#10;        if len(self) &gt; self.maxsize:&#10;            oldest = next(iter(self))&#10;            del self[oldest]&#10;&#10; " description="OrderedDict  размер кэша можно ограничить" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list SWAP elements in list" value="def swap(i, j):&#10;    $arr$[i], $arr$[j] = $arr$[j], $arr$[i]" description="" toReformat="false" toShortenFQNames="true">
    <variable name="arr" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list QUEUE FIFO FIXEDSIZE с вытеснением" value="queue_=[]&#10;queue_[:0] = [12]   # push=enque&#10;v = queue_.pop()    # pop =deque&#10;&#10;dec = collections.deque([1, 2, 3, 4, 5, 6], maxlen=6)&#10;dec.appendleft(101)  # если добавить слева то вытеснится справа&#10;# [101, 1, 2, 3, 4, 5]&#10;dec.append(102) # если добавить справа то вытеснится слева&#10;# [1, 2, 3, 4, 5, 102]" description="deque(maxlen)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list HEAP SUPER with deletion operation" value="class Heap():&#10;    &quot;&quot;&quot; Heap - priority queue.&#10;&#10;    Each element is a tuple (key,value)&#10;    &quot;&quot;&quot;&#10;&#10;    REMOVED = '&lt;removed-task&gt;'  # placeholder for a removed task&#10;&#10;    def __init__(self, list_):  # type: (Heap, Iterable) -&gt; None&#10;        self.heap = list(list_) if list_ else []  # list of entries arranged in a heap&#10;        self.entry_finder = {e[1]: e for e in self.heap}  # mapping of VALUES to entries&#10;        heapq.heapify(self.heap)&#10;&#10;    def push(self, key, value):  # type: (Heap, Any, Hashable) -&gt; None&#10;        &quot;&quot;&quot;Add a new VALUE or update the priority of an existing entry&quot;&quot;&quot;&#10;        if value in self.entry_finder:&#10;            self.remove(value)&#10;        entry = [key, value]&#10;        self.entry_finder[value] = entry&#10;        heapq.heappush(self.heap, entry)&#10;&#10;    def remove(self, value):  # type: (Heap, Hashable) -&gt; None&#10;        &quot;&quot;&quot;Mark an existing VALUE as REMOVED.  Raise KeyError if not found.&quot;&quot;&quot;&#10;        entry = self.entry_finder.pop(value)&#10;        entry[-1] = Heap.REMOVED&#10;&#10;    def find_entry(self, value):  # type: (Heap, Hashable) -&gt; Any&#10;        &quot;&quot;&quot; find entry by value &quot;&quot;&quot;&#10;        return self.entry_finder[value]&#10;&#10;    def peek(self):  # type: (Heap) -&gt; Any&#10;        &quot;&quot;&quot; peek first element &quot;&quot;&quot;&#10;        return self.heap[0]&#10;&#10;    def pop(self):  # type: (Heap) -&gt; Optional[Any]&#10;        &quot;&quot;&quot;Remove and return the lowest priority VALUE. Raise KeyError if empty.&quot;&quot;&quot;&#10;        while self.heap:&#10;            _, value = heapq.heappop(self.heap)&#10;            if value is not Heap.REMOVED:&#10;                del self.entry_finder[value]  # так как это операция pop то удалим также из словаря&#10;                return value&#10;        return None&#10;&#10;    def __repr__(self):&#10;        return f&quot;heap={self.heap} \n dict={self.entry_finder}&quot;" description="NEW  [class sorted by value]  {class hashed by key}" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="func find nearest clothest value" value="idx, val = min(enumerate(points), key=lambda idx_pt:abs(idx_pt[1][0] - to_point[0]))" description="в списке найти значение наиболее близкое к заданному" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="func  число разложить на цифры" value="n = 123&#10;while n &gt; 0:&#10;    n, digit = divmod(n, 10)&#10;    print(digit) # 3 2 1" description="n, digit = divmod(n, 10)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="formap MIN k min elements O(N log k)" value="# 2-3. build heap of top k frequent elements and&#10;# convert it into an output array&#10;# O(N log k) time&#10;counter = collections.Counter(nums)&#10;&#10;# для возвращения используются только ключи словаря&#10;# а для сортировки используем только значения словаря&#10;return heapq.nlargest(k, counter.keys(), key=counter.get)" description="heapq.nlargest" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TRIGGER SUPER" value="trigger = 1&#10;&#10;# flip the trigger&#10;trigger = 1 - trigger" description="trigger = 1 - trigger" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TRIGGER" value="trigger = False&#10;&#10;def run_once(proc):&#10;    nonlocal trigger&#10;    if trigger:&#10;        return&#10;    else:&#10;        trigger = True&#10;        proc()&#10;&#10;def is_only_one_zero(elem):&#10;    nonlocal trigger&#10;    if not trigger and elem == 0:&#10;        trigger = True&#10;        return True&#10;    else:&#10;        return False" description="run only once" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="formap MIN k min elements O(N)" value="def find_k_largest(self, nums: List[int], nth: int) -&gt; int:&#10;        length = len(nums)&#10;        if not nums:&#10;            return 0&#10;        if length &lt; 2:&#10;            return max(nums)&#10;&#10;        def swap(i, j):&#10;            nums[i], nums[j] = nums[j], nums[i]&#10;&#10;        # randomly find pivot&#10;        pivot_index = random.randint(0, length - 1)  # [1,10]&#10;        pivot = nums[pivot_index]&#10;        swap(0, pivot_index)&#10;        border = 1&#10;&#10;        # split above and below pivot&#10;        for j in range(1, length):&#10;            if nums[j] &lt; pivot:&#10;                swap(j, border)&#10;                border += 1&#10;&#10;        # put pivot back&#10;        swap(0, border-1) # важно обменятся с последним элементом их ЛЕВОЙ половины&#10;&#10;        if border == nth:&#10;            return pivot&#10;        if nth &lt; border:&#10;            return self.find_k_largest(nums[:border - 1], nth)&#10;        return self.find_k_largest(nums[border:], nth - border)  # idx больше на еденицу чем I тогда начнем искать с 0 те это след миним эллемент" description="hoara i-order statistic problem" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class LinkedList single 1" value="class Node(object):&#10;    &quot;&quot;&quot; node for single linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self, val):&#10;        self.val = val&#10;        self.next = None&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;&#10;class SingleLinkedList(object):&#10;    &quot;&quot;&quot; single linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        &quot;&quot;&quot; Initialize your data structure here.&quot;&quot;&quot;&#10;        self.head = Node(None)  # sentinel node&#10;        self.size = 0&#10;&#10;    def get(self, index: int) -&gt; int:&#10;        &quot;&quot;&quot; Get the value of the index-th node in the linked list.&#10;&#10;        If the index is invalid, return -1.&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return -1&#10;&#10;        node = self.head&#10;        for _ in range(index + 1):  # because +1 sentinel node&#10;            node = node.next&#10;&#10;        return node.val&#10;&#10;    def addAtHead(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the first element of the linked list.&#10;&#10;        After the insertion, the new node will be the first node of the linked list.&#10;        O(1)&quot;&quot;&quot;&#10;        self.addAtIndex(0, val)&#10;&#10;    def addAtTail(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Append a node of value val to the last element of the linked list.&#10;&#10;        O(N)&quot;&quot;&quot;&#10;        self.addAtIndex(self.size, val)&#10;&#10;    def addAtIndex(self, index: int, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list.&#10;&#10;        If index equals to the length of linked list, the node will be appended to the end of linked list.&#10;        If index is greater than the length, the node will not be inserted.&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt;= self.size:&#10;            return&#10;&#10;        node = self.head&#10;        for _ in range(index):  # get prev node, because +1 sentinel node&#10;            node = node.next&#10;&#10;        new_node = Node(val)&#10;        new_node.next = node.next&#10;        node.next = new_node&#10;&#10;        self.size += 1&#10;&#10;    def deleteAtIndex(self, index: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid.&#10;&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return&#10;&#10;        node = self.head&#10;        for _ in range(index):  # get prev node, because +1 sentinel node&#10;            node = node.next&#10;&#10;        node.next = node.next.next&#10;&#10;        self.size -= 1&#10;&#10;    def __repr__(self):&#10;        list_repr = []&#10;&#10;        node = self.head&#10;        for _ in range(self.size):  # because +1 sentinel node&#10;            node = node.next&#10;            list_repr += [node]&#10;&#10;        return str(list_repr)" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class LinkedList single 2" value="class ListNode(object):&#10;    &quot;&quot;&quot; node for single linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self, val):&#10;        self.val = val&#10;        self.next = None&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;&#10;class SingleLinkedList(object):&#10;    &quot;&quot;&quot; single linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        &quot;&quot;&quot; Initialize your data structure here.&quot;&quot;&quot;&#10;        self.head = ListNode(None)  # sentinel node&#10;        self.size = 0&#10;&#10;    def get(self, index: int) -&gt; int:&#10;        &quot;&quot;&quot; Get the value of the index-th node in the linked list.&#10;&#10;        If the index is invalid, return -1.&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return -1&#10;&#10;        node = self.head&#10;        for _ in range(index + 1):  # because + 0-th node&#10;            node = node.next&#10;&#10;        return node.val&#10;&#10;    def add_at_head(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the first element of the linked list.&#10;&#10;        After the insertion, the new node will be the first node of the linked list.&#10;        O(1)&quot;&quot;&quot;&#10;        self.add_at_index(0, val)&#10;&#10;    def add_at_tail(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Append a node of value val to the last element of the linked list.&#10;&#10;        O(N)&quot;&quot;&quot;&#10;        self.add_at_index(self.size, val)&#10;&#10;    def add_at_index(self, index: int, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list.&#10;&#10;        If index equals to the length of linked list, the node will be appended to the end of linked list.&#10;        If index is greater than the length, the node will not be inserted.&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt;= self.size:&#10;            return&#10;&#10;        node_prev = self.head&#10;        for _ in range(index):  # prev node, because without 0-th node&#10;            node_prev = node_prev.next&#10;        node_next = node_prev.next&#10;&#10;        node_prev.next = node_new = ListNode(val)&#10;        node_new.next = node_next&#10;&#10;        self.size += 1&#10;&#10;    def delete_at_index(self, index: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid.&#10;&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return&#10;&#10;        node_prev = self.head&#10;        for _ in range(index):  # prev node, because without 0-th node&#10;            node_prev = node_prev.next&#10;        node_next = node_prev.next.next&#10;&#10;        node_prev.next = node_next&#10;&#10;        self.size -= 1&#10;&#10;    def __repr__(self):&#10;        list_repr = []&#10;&#10;        node = self.head&#10;        for _ in range(self.size):  # because size is a count of elements&#10;            node = node.next&#10;            list_repr += [node]&#10;&#10;        return str(list_repr)&#10;&#10;&#10;N1, N2, N3, N4, N5 = ListNode(1), ListNode(2), ListNode(3), ListNode(4), ListNode(5)&#10;N1.next, N2.next, N3.next, N4.next = N2, N3, N4, N5&#10;L = SingleLinkedList()&#10;L.head.next = N1&#10;L.size=5&#10;print(L)" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class LinkedList double" value="class ListNode(object):&#10;    &quot;&quot;&quot; node for single linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self, val):&#10;        self.val = val&#10;        self.prev = None&#10;        self.next = None&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;&#10;class DoubleLinkedList(object):&#10;    &quot;&quot;&quot; double linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        &quot;&quot;&quot; Initialize your data structure here.&quot;&quot;&quot;&#10;        self.head = ListNode(&quot;HEAD&quot;)  # sentinel node&#10;        self.tail = ListNode(&quot;TAIL&quot;)&#10;&#10;        self.head.next = self.tail&#10;        self.tail.prev = self.head&#10;&#10;        self.size = 0&#10;&#10;    def get(self, index: int) -&gt; int:&#10;        &quot;&quot;&quot; Get the value of the index-th node in the linked list.&#10;&#10;        If the index is invalid, return -1.&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return -1&#10;&#10;        if index + 1 &lt; self.size - index:&#10;            node = self.head&#10;            for _ in range(index + 1):  # because + 0-th node&#10;                node = node.next&#10;        else:&#10;            node = self.tail&#10;            for _ in range(self.size - index):&#10;                node = node.prev&#10;&#10;        return node.val&#10;&#10;    def addAtHead(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the first element of the linked list.&#10;&#10;        After the insertion, the new node will be the first node of the linked list.&#10;        O(1)&quot;&quot;&quot;&#10;        self.addAtIndex(0, val)&#10;&#10;    def addAtTail(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Append a node of value val to the last element of the linked list.&#10;&#10;        O(1)&quot;&quot;&quot;&#10;        self.addAtIndex(self.size, val)&#10;&#10;    def addAtIndex(self, index: int, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list.&#10;&#10;        If index equals to the length of linked list, the node will be appended to the end of linked list.&#10;        If index is greater than the length, the node will not be inserted.&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt;= self.size:&#10;            return&#10;&#10;        if index + 1 &lt; self.size - index:&#10;            node_prev = self.head&#10;            for _ in range(index):  # get prev node, because without 0-th node&#10;                node_prev = node_prev.next&#10;            node_next = node_prev.next&#10;        else:&#10;            node_next = self.tail&#10;            for _ in range(self.size - index):  # get exactly node for insertion position (currently it is succ node)&#10;                node_next = node_next.prev&#10;            node_prev = node_next.prev&#10;&#10;        node_prev.next = node_next.prev = node_new = ListNode(val)&#10;        node_new.prev = node_prev&#10;        node_new.next = node_next&#10;&#10;        self.size += 1&#10;&#10;    def deleteAtIndex(self, index: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid.&#10;&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return&#10;&#10;        if index + 1 &lt; self.size - index:&#10;            node_prev = self.head&#10;            for _ in range(index):  # get prev node, because without 0-th node&#10;                node_prev = node_prev.next&#10;            node_next = node_prev.next.next  # eventualy it is succ node&#10;        else:&#10;            node_next = self.tail&#10;            for _ in range(self.size - index - 1):  # get exactly node for deleted position ( -1next  it is succ node)&#10;                node_next = node_next.prev&#10;            node_prev = node_next.prev.prev  # eventualy it is pred node&#10;&#10;        node_prev.next = node_next&#10;        node_next.prev = node_prev&#10;&#10;        self.size -= 1&#10;&#10;    def __repr__(self):&#10;        list_repr = []&#10;&#10;        node = self.head&#10;        for _ in range(self.size):  # because size is a count of elements&#10;            node = node.next&#10;            list_repr += [node]&#10;&#10;        return str(list_repr)&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE  LRU Least recently used FIXEDSIZE SUPER" value="class LRU(collections.OrderedDict):&#10;    &quot;&quot;&quot; Limit size, evicting the least recently looked-up key when full &quot;&quot;&quot;&#10;&#10;    def __init__(self, maxsize=128, /, *args, **kwds):&#10;        self.maxsize = maxsize&#10;        super().__init__(*args, **kwds)&#10;&#10;    def __getitem__(self, key):&#10;        value = super().__getitem__(key)&#10;        self.move_to_end(key)&#10;        return value&#10;&#10;    def __setitem__(self, key, value):&#10;        super().__setitem__(key, value)&#10;        self.move_to_end(key)&#10;        if len(self) &gt; self.maxsize:&#10;            self.popitem(last=False)&#10;&#10; " description="OrderedDict  размер кэша можно ограничить" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new DoubleLinkedListAndDict" value="class Node(object):&#10;    &quot;&quot;&quot; node for single linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self, val):&#10;        self.val = val&#10;        self.prev = None&#10;        self.next = None&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;class DoubleLinkedListAndDict(object):&#10;    &quot;&quot;&quot; list works with node itself, not its vals. Most operations O(1). Ordered or sorted list also.&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        &quot;&quot;&quot; Initialize your data structure here.&quot;&quot;&quot;&#10;        self.head = Node(&quot;HEAD&quot;)  # sentinel node&#10;        self.tail = Node(&quot;TAIL&quot;)&#10;&#10;        self.head.next = self.tail&#10;        self.tail.prev = self.head&#10;&#10;        self.size = 0&#10;&#10;        self.cache = {}&#10;        self.cache[-1] = self.head&#10;&#10;    def get(self, index: int) -&gt; Node:&#10;        &quot;&quot;&quot; Get the value of the index-th node in the linked list.&#10;&#10;        If the index is invalid, return -1.&#10;        O(1)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return -1&#10;&#10;        return self.cache.get(index, -1)&#10;&#10;    def _get(self, index: int) -&gt; Node:&#10;        # please notice, no check input args !&#10;        node = self.cache.get(index, -1)&#10;        return node, node.next&#10;&#10;    def addAtHead(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the first element of the linked list.&#10;&#10;        After the insertion, the new node will be the first node of the linked list.&#10;        O(1)&quot;&quot;&quot;&#10;        self.addAtIndex(0, val)&#10;&#10;    def addAtTail(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Append a node of value val to the last element of the linked list.&#10;&#10;        O(1)&quot;&quot;&quot;&#10;        self.addAtIndex(self.size, val)&#10;&#10;    def addAtIndex(self, index: int, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list.&#10;&#10;        If index equals to the length of linked list, the node will be appended to the end of linked list.&#10;        If index is greater than the length, the node will not be inserted.&#10;        O(1)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt;= self.size:&#10;            return&#10;&#10;        node_prev, node_next = self._get(index - 1)&#10;&#10;        node_prev.next = node_next.prev = node_new = Node(val)&#10;        node_new.prev = node_prev&#10;        node_new.next = node_next&#10;&#10;        self.size += 1&#10;        self.cache[index] = node_new&#10;&#10;    def deleteAtIndex(self, index: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid.&#10;&#10;        O(1)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return&#10;&#10;        node_prev, node_next = self._get(index - 1)&#10;&#10;        node_prev.next = node_next&#10;        node_next.prev = node_prev&#10;&#10;        self.size -= 1&#10;        del self.cache[index]&#10;&#10;    def __repr__(self):&#10;        list_repr = []&#10;&#10;        node = self.head&#10;        for _ in range(self.size):  # because size is a count of elements&#10;            node = node.next&#10;            list_repr += [node]&#10;&#10;        return str(list_repr)&#10;" description="operations O(1). Ordered or sorted list also." toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function CYCLE FIND v1" value="# множество можно использовать для обнаружения циклов уже виденных элементов&#10;seen=set()&#10;while node:&#10;    if node in seen:&#10;        return True # found cycle!&#10;    else:&#10;        seen|= {node}&#10;    node= node.next" description="множество можно использовать для обнаружения циклов уже виденных элементов" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TEMPLATE  two_pointers for linked list" value="# Initialize slow &amp; fast pointers&#10;node_slow = head&#10;node_fast = head&#10;# Change this condition to fit specific problem.&#10;# Attention: remember to avoid null-pointer error&#10;while node_slow and node_fast and node_fast.next:&#10;    node_slow = node_slow.next  # move slow pointer one step each time&#10;    node_fast = node_fast.next.next  # move fast pointer two steps each time&#10;    if node_slow == node_fast:  # change this condition to fit specific problem&#10;        return True&#10;&#10;return False  # change return value to fit specific problem" description="from LEETCODE" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="listlinked _insert_node" value="def _insert_node(self, prev, curr, next):&#10;    prev.next = curr&#10;    curr.next = next" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function CYCLE FIND v2" value="# множество можно использовать для обнаружения циклов уже виденных элементов&#10;node, seen = llist, set()&#10;while node and node not in seen:&#10;    # main work   &#10;      &#10;    seen|= {node}&#10;    node= node.next&#10;" description="множество можно использовать для обнаружения циклов уже виденных элементов" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class binary tree" value="&#10;class TreeNode(object):&#10;    &quot;&quot;&quot; binary tree node&quot;&quot;&quot;&#10;&#10;    def __init__(self, x):&#10;        self.val = x&#10;        self.left = None&#10;        self.right = None&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;&#10;class BinaryTree(object):&#10;    &quot;&quot;&quot; ok &quot;&quot;&quot;&#10;&#10;    # &lt;editor-fold desc=&quot;DFS pre order&quot;&gt;&#10;    def preorder_traversal_recursive_bottomup(self, node: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER  DFS  O(N)ST tree pre-order traversal recursive(bottom-up)&quot;&quot;&quot;&#10;        if not node:&#10;            return []&#10;&#10;        tree_left = self.preorder_traversal_recursive_bottomup(node.left)&#10;        tree_right = self.preorder_traversal_recursive_bottomup(node.right)&#10;        return [node.val] + tree_left + tree_right&#10;&#10;    def preorder_traversal_recursive_topdown(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)ST DFS tree pre-order traversal recursive(top-down)&quot;&quot;&quot;&#10;        traverse = []&#10;&#10;        def helper(node):&#10;            nonlocal traverse&#10;            if not node:&#10;                return&#10;&#10;            traverse += [node.val]&#10;            helper(node.left)&#10;            helper(node.right)&#10;&#10;        helper(root)&#10;        return traverse&#10;&#10;    def preorder_traversal_iterative(self, root: TreeNode) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER DFS O(N)T O(1)S tree pre-order traversal &quot;&quot;&quot;&#10;        stack = [root]&#10;        while node := stack.pop() if stack else None:&#10;            yield node.val  # main work&#10;&#10;            if node.right:&#10;                stack += [node.right]&#10;            if node.left:&#10;                stack += [node.left]  # would be on top of stack, left node processed first&#10;&#10;    def preorder_traversal_iterative2(self, root: TreeNode) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER DFS O(N)T O(1)S tree pre-order traversal&#10;&#10;        допускаются None элементы в стэке&#10;        &quot;&quot;&quot;&#10;        stack = [root]&#10;        while stack:&#10;            node = stack.pop()&#10;            if node is None:&#10;                continue&#10;            yield node.val  # main work&#10;&#10;            stack += [node.right]&#10;            stack += [node.left]  # would be on top of stack, left node processed first&#10;&#10;    def preorder_traversal_iterative_variant(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot; DFS O(N)T O(1)S tree pre-order traversal &quot;&quot;&quot;&#10;        result = []&#10;&#10;        stack = [root]&#10;        while node := stack.pop() if stack else None:&#10;            result += [node.val]  # main work&#10;&#10;            if node.right:&#10;                stack += [node.right]&#10;            if node.left:&#10;                stack += [node.left]  # would be on top of stack, left node processed first&#10;&#10;        return result&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;DFS in order&quot;&gt;&#10;    def inorder_traversal_recursive_bottomup(self, node: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree in-order traversal recursive(bottom-up)&quot;&quot;&quot;&#10;        if not node:&#10;            return []&#10;&#10;        tree_left = self.inorder_traversal_recursive_bottomup(node.left)&#10;        tree_right = self.inorder_traversal_recursive_bottomup(node.right)&#10;        return tree_left + [node.val] + tree_right&#10;&#10;    def inorder_traversal_recursive_topdown(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)ST tree in-order traversal recursive(top-down)&quot;&quot;&quot;&#10;        traverse = []&#10;&#10;        def helper(node):&#10;            nonlocal traverse&#10;            if not node:&#10;                return&#10;&#10;            helper(node.left)&#10;            traverse += [node.val]&#10;            helper(node.right)&#10;&#10;        helper(root)&#10;&#10;        return traverse&#10;&#10;&#10;    def inorder_traversal_iterative(self, root: TreeNode) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER O(N)T O(1)S tree in-order traversal&#10;&#10;        - сначала в стек разворачиваем левую ветвь&#10;        - затем достаем из стека = это и будет элемент&#10;        а после посещения вершины нужно перенаправить на правую ветвь&#10;&#10;        Нам не нужно проверять левый дочерний элемент из-за способа добавления узлов в стек. У самого верхнего в стеке узла либо не будет left дочернего элемента, либо уже будет left обработаное поддерево.&#10;        &quot;&quot;&quot;&#10;        stack, node = [], root&#10;        while stack or node:&#10;            while node:  # только, если есть правая нода, оставшаяся от предыдущей итерации&#10;                stack += [node]&#10;                node = node.left&#10;            node = stack.pop()&#10;            yield node.val  # main work&#10;            node = node.right  # после доставания центра созраним правую ноду&#10;&#10;    def inorder_traversal_iterative_variant1(root: TreeNode) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;O(N)ST tree in-order traversal&#10;    &#10;        without helper node, state only in stack&#10;        &quot;&quot;&quot;&#10;        stack = []&#10;    &#10;        def add_left_branch(branch):&#10;            nonlocal stack&#10;            while branch:  # только, если есть правая нода, оставшаяся от предыдущей итерации&#10;                stack += [branch]&#10;                branch = branch.left&#10;    &#10;        add_left_branch(root)&#10;        while node := stack.pop() if stack else None:&#10;            yield node.val  # main work&#10;            add_left_branch(node.right)&#10;&#10;    def inorder_traversal_iterative_variant2(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)ST tree in-order traversal &#10;        &#10;        using list instead generator&#10;        &quot;&quot;&quot;&#10;        result = []&#10;&#10;        stack, node = [], root&#10;        while stack or node:&#10;            while node:&#10;                stack += [node]&#10;                node = node.left&#10;            node = stack.pop()&#10;            result += [node.val]  # main work&#10;            node = node.right&#10;&#10;        return result&#10;&#10;    def inorder_traversal_moris(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)T O(1)S tree in-order traversal &quot;&quot;&quot;&#10;        node = root&#10;        while node:&#10;            if not node.left:  # если слева нет ноды то выводим текущую в результат и делаем текущей правую ноду&#10;                yield node.val&#10;                node = node.right&#10;            else:  # если слева есть нода, то зацикливаем.. и делаем ее текущей&#10;                node_next_curr = node.left&#10;&#10;                # find last&#10;                node_right_branch = node.left&#10;                while node_right_branch:&#10;                    node_right_branch_end = node_right_branch&#10;                    node_right_branch = node_right_branch.right&#10;&#10;                # create cycle&#10;                node_right_branch_end.right = node&#10;                node.left = None  # TODO(wilmer.krisp@yahoo.com) breaks source tree&#10;&#10;                node = node_next_curr&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;DFS post order&quot;&gt;&#10;    def postorder_traversal_recursive_bottomup(self, node: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree post-order traversal recursive(bottom-up)&quot;&quot;&quot;&#10;        if not node:&#10;            return []&#10;&#10;        tree_left = self.postorder_traversal_recursive_bottomup(node.left)&#10;        tree_right = self.postorder_traversal_recursive_bottomup(node.right)&#10;        return tree_left + tree_right + [node.val]&#10;&#10;    def postorder_traversal_recursive_topdown(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)ST tree post-order traversal recursive(top-down)&quot;&quot;&quot;&#10;        traverse = []&#10;&#10;        def helper(node):&#10;            nonlocal traverse&#10;            if not node:&#10;                return&#10;&#10;            helper(node.left)&#10;            helper(node.right)&#10;            traverse += [node.val]&#10;&#10;        helper(root)&#10;&#10;        return traverse&#10;&#10;    def postorder_traversal_iterative(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree post-order traversal &quot;&quot;&quot;&#10;&#10;        return list(self.preorder_traversal_iterative(root))[::-1]&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;BFS level order&quot;&gt;&#10;    def levelorder_traversal_iterative(self, root: TreeNode):&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal &quot;&quot;&quot;&#10;        queue = collections.deque([root])&#10;        while node := queue.pop() if queue else None:&#10;            yield node.val  # main work&#10;&#10;            if node.left:&#10;                queue.appendleft(node.left)&#10;            if node.right:&#10;                queue.appendleft(node.right)&#10;&#10;    def levelorder_traversal_recursive_topdown(self, root: TreeNode) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal recursive(top-down)&quot;&quot;&quot;&#10;        levels = collections.defaultdict(list)&#10;        if not root:&#10;            return levels.values()&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return&#10;            levels[level] += [node.val]&#10;            helper(node.left, level + 1)&#10;            helper(node.right, level + 1)&#10;&#10;        helper(root, 0)&#10;&#10;        # значения будут складываться в словарь в порядке обхода слоями, поэтому ненужна сортировка по level&#10;        return itertools.chain.from_iterable(levels.values())&#10;&#10;    def levelorder_traversal_recursive_bottomup(self, root: TreeNode) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot; BFS O(N)ST tree level-order traversal recursive(bottom up)&quot;&quot;&quot;&#10;        if not root:&#10;            return []&#10;&#10;        def group_dicts(*dicts):&#10;            &quot;&quot;&quot; group_dicts(map1, map2, map3)&quot;&quot;&quot;&#10;            items = [d.items() for d in dicts]&#10;            merged = collections.defaultdict(list)&#10;            for key, value in itertools.chain.from_iterable(items):&#10;                merged[key] += value&#10;            return merged&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return {}&#10;&#10;            level_node = {&#10;                level: [node.val]&#10;            }&#10;            level_left = helper(node.left, level + 1)&#10;            level_right = helper(node.right, level + 1)&#10;            return group_dicts(level_left, level_right, level_node)&#10;&#10;        levels = helper(root, 0).items()&#10;        levels_sorted = sorted(levels)&#10;        levels_vals = [value for key, value in levels_sorted]&#10;        return itertools.chain.from_iterable(levels_vals)&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;BFS level order with levelNum&quot;&gt;&#10;    def levelorder_traversal_recursive_withlevelnum(self, root: TreeNode) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal &quot;&quot;&quot;&#10;        levels = collections.defaultdict(list)&#10;        if not root:&#10;            return levels.values()&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return&#10;            levels[level] += [node.val]&#10;            helper(node.left, level + 1)&#10;            helper(node.right, level + 1)&#10;&#10;        helper(root, 0)&#10;&#10;        return levels.values()&#10;&#10;    def levelorder_traversal_iterative_withlevelnum_var1(self, root: TreeNode) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal&#10;&#10;        суперподход: запихнуть вместе с нодой в стек дополнительную информацию&#10;        те в стеке кортеж (нода, значение)&#10;&#10;        stack based&#10;        &quot;&quot;&quot;&#10;        levels = collections.defaultdict(list)&#10;&#10;        stack = [(1, root)] if root else None  # проверка на пустоту&#10;        while stack:&#10;            level, node = stack.pop()&#10;            levels[level] += [node.val]&#10;&#10;            if node.left:&#10;                stack += [(level + 1, node.left)]&#10;            if node.right:&#10;                stack += [(level + 1, node.right)]&#10;&#10;        return levels.values()&#10;&#10;    def levelorder_traversal_iterative_withlevelnum_var1b(self, root: TreeNode) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot; BFS O(N)ST tree level-order traversal&#10;&#10;        queue based&#10;        &quot;&quot;&quot;&#10;        levels = collections.defaultdict(list)&#10;&#10;        queue = collections.deque([(1, root)]) if root else None  # проверка на пустоту&#10;        while queue:&#10;            level, node = queue.pop()&#10;            levels[level] += [node.val]&#10;&#10;            if node.left:&#10;                queue.appendleft((level + 1, node.left))&#10;            if node.right:&#10;                queue.appendleft((level + 1, node.right))&#10;&#10;        return levels.values()&#10;&#10;    def levelorder_traversal_iterative_withlevelnum_var2(self, root: TreeNode) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot; BFS O(N)ST tree level-order traversal&#10;&#10;        принцип комплиментарности&#10;&#9;    - выберем справа все ноды данного уровня , все равно добавлять ноды будем с другого конца,&#10;&#9;    поэтому они не смешаются (и я случайно не выберу только что добавленную ноду)&#10;        после добавления всех нод (и удаления всех нод текущего уровня) = это и есть ноды следующего уровня&#10;&#10;        - после исчерпывания нод во внутреннем цикле for мы собираем цровень целиком&#10;        &quot;&quot;&quot;&#10;&#10;        queue = collections.deque([root]) if root else None  # проверка на пустоту&#10;        while queue:&#10;            level_len, level = len(queue), []&#10;&#10;            for _ in range(level_len):  # из всех нод находящихся сейчас в стеке собираем уровень&#10;                node = queue.pop()&#10;                level += [node.val]&#10;&#10;                if node.left:&#10;                    queue.appendleft(node.left)  # все равно добавлять ноды будем с другого конца, поэтому они не смешаются&#10;                if node.right:&#10;                    queue.appendleft(node.right)&#10;&#10;            yield level&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;various methods&quot;&gt;&#10;    def compare_trees_recursive(self, root1, root2):&#10;        &quot;&quot;&quot; compare two trees recursive&quot;&quot;&quot;&#10;        if not root1 and not root2:&#10;            return True&#10;        if not root1 or not root2:&#10;            return False&#10;        return root1.val == root2.val and self.compare_trees_recursive(root1.left, root2.left) and self.compare_trees_recursive(root1.right, root2.right)&#10;&#10;    def compare_trees_iterative(self, root1, root2):&#10;        &quot;&quot;&quot;SUPER compare two trees iterative&#10;&#10;        в стек записали кортеж из двух нод внутри&#10;        &quot;&quot;&quot;&#10;        stack = [(root1, root2)]&#10;        while stack:&#10;            node1, node2 = stack.pop()&#10;            if not node1 and not node2:  # тк список может хранить None значения&#10;                continue&#10;            if not node1 or not node2:&#10;                return False&#10;            if node1.val != node2.val:&#10;                return False&#10;            stack += [(node1.right, node2.right), (node1.left, node2.left)]&#10;        return True&#10;&#10;    def compare_trees_iterative_variant(self, root1, root2):&#10;        &quot;&quot;&quot; compare two trees iterative&quot;&quot;&quot;&#10;        stack = [root2, root1]&#10;        while stack:&#10;            node1, node2 = stack.pop(), stack.pop() if stack else None&#10;            if not node1 and not node2:  # тк список может хранить None значения&#10;                continue&#10;            if not node1 or not node2:&#10;                return False&#10;            if node1.val != node2.val:&#10;                return False&#10;            stack += [node2.right, node1.right, node2.left, node1.left]&#10;        return True&#10;&#10;    def serialize_recursive(self, node):&#10;        &quot;&quot;&quot; pre-order recursive(bottom-up) traversal &quot;&quot;&quot;&#10;        if not node:&#10;            return 'None'&#10;&#10;        tree_left = self.serialize_recursive(node.left)&#10;        tree_right = self.serialize_recursive(node.right)&#10;        return str(node.val) + ',' + tree_left + ',' + tree_right&#10;&#10;    def serialize_iterative(self, root):&#10;        &quot;&quot;&quot; pre-order iterative traversal &quot;&quot;&quot;&#10;        tree_list = []&#10;&#10;        stack = [root]&#10;        while stack:&#10;            node = stack.pop()&#10;            tree_list += [str(node.val) if node else 'None']  # main work&#10;            if node is None:&#10;                continue&#10;&#10;            stack += [node.right, node.left]  # would be on top of stack, left node processed first&#10;&#10;        return &quot;,&quot;.join(tree_list)&#10;&#10;    def deserialize_recursive(self, data):&#10;        &quot;&quot;&quot; pre-order recursive(bottom-up) traversal &quot;&quot;&quot;&#10;        if not data:&#10;            return&#10;        &#10;        tree_list = data.split(',')&#10;&#10;        def traversal():&#10;            node_next = tree_list.pop(0)&#10;            if node_next == 'None':&#10;                return None&#10;&#10;            node_new = TreeNode(int(node_next))&#10;            node_new.left = traversal()&#10;            node_new.right = traversal()&#10;            return node_new&#10;&#10;        return traversal()&#10;&#10;    def deserialize_iterative(self, data):&#10;        &quot;&quot;&quot; pre-order iterative traversal &quot;&quot;&quot;&#10;        if not data:&#10;            return &#10;        &#10;        tree_list = data.split(',')&#10;        tree_list.reverse()&#10;&#10;        node_sentinel = TreeNode(0)&#10;        stack = [functools.partial(node_sentinel.__setattr__, &quot;left&quot;)]&#10;        while stack and tree_list:&#10;            command = stack.pop()&#10;            val = tree_list.pop()&#10;&#10;            if val == 'None':&#10;                command(None)&#10;                continue&#10;&#10;            node_new = TreeNode(val)  # main work&#10;            command(node_new)&#10;            stack += [functools.partial(node_new.__setattr__, &quot;right&quot;), functools.partial(node_new.__setattr__, &quot;left&quot;)]&#10;&#10;        return node_sentinel.left&#10;&#10;    def max_depth(self, root: TreeNode) -&gt; int:   &#10;        &quot;&quot;&quot; lever-order traversion, recursive bottom-up&quot;&quot;&quot;&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return level&#10;&#10;            return max(helper(node.left, level + 1), helper(node.right, level + 1))&#10;&#10;        return helper(root, 0)&#10;&#10;    pass  # &lt;/editor-fold&gt;&#10;&#10;&#10;T1, T2, T3, T4, T5 = TreeNode(1), TreeNode(2), TreeNode(3), TreeNode(4), TreeNode(5)&#10;T1.left, T1.right = T2, T3&#10;T2.left, T2.right = T4, T5&#10;wilmerlibrary.draw_binary_tree(T1)" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal recursive preorder binary tree" value="def traversal( node_root):&#10;    if not node_root:&#10;        return []&#10;&#10;    tree_left = traversal(node_root.left)&#10;    tree_right = traversal(node_root.right)&#10;    return [node_root.val] + tree_left + tree_right" description="SUPER O(N)ST tree pre-order traversal recursive(bottom-up)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal iterative preorder binary tree (STACK BASED DFS)" value="def traversal(node_root):&#10;    stack = [node_root]&#10;    while node := stack.pop() if stack else None:&#10;        yield node.val  # main work&#10;&#10;        if node.right:&#10;            stack += [node.right]&#10;        if node.left:&#10;            stack += [node.left]  # would be on top of stack, left node processed first" description="SUPER O(N)ST tree pre-order traversal" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal iterative levelorder binary tree (QUEUE BASED BFS)" value="def traversal(node_root):&#10;    queue = collections.deque([node_root])&#10;    while node := queue.pop() if queue else None:&#10;        yield node.val  # main work&#10;&#10;        if node.left:&#10;            queue.appendleft(node.left)&#10;        if node.right:&#10;            queue.appendleft(node.right)" description="SUPER BFS O(N)ST tree level-order traversal" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal recursive levelorder binary tree (GROUPED LEVELS)" value="def traversal( node_root ) :&#10;    levels = collections.defaultdict(list)&#10;    if not node_root:&#10;        return levels.values()&#10;&#10;    def helper(node, level):&#10;        if not node:&#10;            return&#10;        levels[level] += [node.val]&#10;        helper(node.left, level + 1)&#10;        helper(node.right, level + 1)&#10;&#10;    helper(node_root, 0)&#10;&#10;    return itertools.chain.from_iterable(levels.values()) # levels.values() если нужно получить просто группы" description="SUPER O(N)ST tree level-order traversal recursive(top-down)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal iterative levelorder binary tree (ADDITIONAL INFO IN STACK)" value="def traversal(node_root )  :&#10;    levels = collections.defaultdict(list)&#10;&#10;    stack = [(1, node_root)]&#10;    while stack:&#10;        level, node = stack.pop()&#10;        levels[level] += [node.val]&#10;&#10;        if node.left:&#10;            stack += [(level + 1, node.left)]&#10;        if node.right:&#10;            stack += [(level + 1, node.right)]&#10;&#10;    return levels.values()" description="SUPER O(N)ST tree level-order traversal" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal compare tree" value="def compare_trees_recursive(root1, root2):&#10;    &quot;&quot;&quot; compare two trees recursive&quot;&quot;&quot;&#10;    if not root1 and not root2:&#10;        return True&#10;    if not root1 or not root2:&#10;        return False&#10;    return root1.val == root2.val and self.compare_trees_recursive(root1.left, root2.left) and self.compare_trees_recursive(root1.right, root2.right)&#10;&#10;def compare_trees_iterative(root1, root2):&#10;    &quot;&quot;&quot; compare two trees iterative&quot;&quot;&quot;&#10;    stack = [root2, root1]&#10;    while stack:&#10;        node1, node2 = stack.pop(), stack.pop() if stack else None&#10;        if not node1 and not node2: # тк список может хранить None значения&#10;            continue&#10;        if not node1 or not node2:&#10;            return False&#10;        if node1.val != node2.val:&#10;            return False&#10;        stack += [node2.right, node1.right, node2.left, node1.left]&#10;    return True" description="recursive and iterative" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal iterative preorder binary tree (STACK BASED DFS + None elements)" value="def traversal(node_root):            &#10;    stack = [node_root]&#10;    while stack:&#10;        node = stack.pop()&#10;        yield node.val  # main work&#10;        if node is None: # стэк может содержать пустые элементы&#10;            continue&#10;&#10;        stack += [node.right, node.left]  # left would be on top of stack, left node processed first" description="SUPER O(N)ST tree pre-order traversal" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class binary search tree BST" value="&#10;class TreeNode(object):&#10;    &quot;&quot;&quot; binary tree node&quot;&quot;&quot;&#10;&#10;    def __init__(self, x):&#10;        self.val = x&#10;        self.left = None&#10;        self.right = None&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;class BinarySearchTree(object):&#10;    &quot;&quot;&quot; BST&#10;&#10;    inorder traversal выводит BST в порядке возрастания&#10;    &quot;&quot;&quot;&#10;&#10;    # &lt;editor-fold desc=&quot;DFS inorder traversal&quot;&gt;&#10;    def inorder_traversal_recursive_bottomup(self, node: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree in-order traversal recursive(bottom-up)&quot;&quot;&quot;&#10;        if not node:&#10;            return []&#10;&#10;        tree_left = self.inorder_traversal_recursive_bottomup(node.left)&#10;        tree_right = self.inorder_traversal_recursive_bottomup(node.right)&#10;        return tree_left + [node.val] + tree_right&#10;&#10;    def inorder_traversal_iterative(self, root: TreeNode) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree in-order traversal&#10;&#10;        - сначала в стек разворачиваем левую ветвь&#10;        - затем достаем из стека = это и будет элемент&#10;        а после посещения вершины нужно перенаправить на правую ветвь&#10;&#10;        Нам не нужно проверять левый дочерний элемент из-за способа добавления узлов в стек. У самого верхнего в стеке узла либо не будет left дочернего элемента, либо уже будет left обработаное поддерево.&#10;        &quot;&quot;&quot;&#10;        stack, node = [], root&#10;        while stack or node:&#10;            while node:  # только, если есть правая нода, оставшаяся от предыдущей итерации&#10;                stack += [node]&#10;                node = node.left&#10;            node = stack.pop()&#10;            yield node.val  # main work&#10;            node = node.right  # после доставания центра созраним правую ноду&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;search in BST&quot;&gt;&#10;    def search_iterative(self, root: TreeNode, val: int) -&gt; TreeNode:&#10;        &quot;&quot;&quot; O(height of tree)T O(1)S iterative tree traversal &quot;&quot;&quot;&#10;        node = root&#10;        while node:&#10;            if node.val == val:&#10;                return node&#10;            node = node.right if val &gt; node.val else node.left&#10;        return None&#10;&#10;    def search_recursive(self, root: TreeNode, val: int) -&gt; TreeNode:&#10;        &quot;&quot;&quot; O(height of tree)T O(height of tree)S recursive tree traversal &quot;&quot;&quot;&#10;        if root is None or val == root.val:&#10;            return root&#10;&#10;        return self.search_recursive(root.right, val) if val &gt; root.val else self.search_recursive(root.left, val)&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;CRUD&quot;&gt;&#10;    def insert_iterative(self, root: TreeNode, val: int) -&gt; TreeNode:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; O(height of tree)T O(1)S iterative tree insertion&#10;&#10;        - если вставка в пустое дерево, то вернуть ссылку на новый корень&#10;        &quot;&quot;&quot;&#10;&#10;        node, node_new = root, TreeNode(val)&#10;        while node:  # обычный поиск по BST&#10;            if val &gt; node.val:&#10;                if node.right:&#10;                    node = node.right&#10;                else:&#10;                    node.right = node_new  # если правой ноды нет то вставляем&#10;                    return root&#10;            else:&#10;                if node.left:&#10;                    node = node.left&#10;                else:&#10;                    node.left = node_new  # если левой ноды нет то вставляем&#10;                    return root&#10;        return node_new&#10;&#10;    def insert_recursive(self, root: TreeNode, val: int) -&gt; TreeNode:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; O(height of tree)T O(height of tree)S recursive tree insertion&#10;&#10;        - если вставка в пустое дерево, то вернуть ссылку на новый корень&#10;        &quot;&quot;&quot;&#10;        if not root:&#10;            return TreeNode(val)  # добавляем новую ноду&#10;&#10;        if val &gt; root.val:&#10;            root.right = self.insert_recursive(root.right, val)  # right=right, просто пересобираем дерево&#10;        else:&#10;            root.left = self.insert_recursive(root.left, val)  # left=left, просто пересобираем дерево&#10;&#10;        return root&#10;&#10;    def delete_recursive(self, root: TreeNode, key: int) -&gt; TreeNode:&#10;        &quot;&quot;&quot; сохраняет ссылку на удаленную ноду, просто заменяет значение&#10;&#10;        - если удаляем корень то возвращает ссылку на новый корень&#10;        &quot;&quot;&quot;&#10;&#10;        def successor(some_node):&#10;            node = some_node.right&#10;            while node.left:  # .left чтобы вернуть непустую ноду&#10;                node = node.left&#10;            return node.val  # ! возвращает значение а не ноду&#10;&#10;        def predcessor(some_node):&#10;            node = some_node.left&#10;            while node.right:&#10;                node = node.right&#10;            return node.val&#10;&#10;        if not root:&#10;            return None&#10;&#10;        # просто двигаемся по дереву&#10;        if key &gt; root.val:&#10;            root.right = self.delete_recursive(root.right, key)&#10;            return root&#10;        elif key &lt; root.val:&#10;            root.left = self.delete_recursive(root.left, key)&#10;            return root&#10;&#10;        # если нашли искомую ноду&#10;        if not root.left and not root.right:&#10;            return None&#10;        if root.right:&#10;            root.val = successor(root)  # сохраняет ссылку на удаленную ноду, просто заменяет значение&#10;            root.right = self.delete_recursive(root.right, root.val)&#10;        else:&#10;            root.val = predcessor(root)&#10;            root.left = self.delete_recursive(root.left, root.val)&#10;&#10;        return root&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;balancing&quot;&gt;&#10;    def is_balanced(self, root: TreeNode) -&gt; bool:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; ok &quot;&quot;&quot;&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return level, False&#10;&#10;            height1, delta1 = helper(node.left, level + 1)&#10;            height2, delta2 = helper(node.right, level + 1)&#10;&#10;            return max(height1, height2), abs(height1 - height2) &gt; 1 or delta1 or delta2&#10;&#10;        _, delta = helper(root, 0)&#10;        return not delta&#10;&#10;    def sorted_array_to_balanced_tree(self, nums: List[int]) -&gt; TreeNode:&#10;        &quot;&quot;&quot; O(N)TS &quot;&quot;&quot;&#10;&#10;        def helper(left, right):&#10;            if left &gt;= right:&#10;                return&#10;&#10;            mid = (right - left - 1) // 2 + left&#10;            node = TreeNode(nums[mid])&#10;            node.left = helper(left, mid)&#10;            node.right = helper(mid + 1, right)&#10;            return node&#10;&#10;        return helper(0, len(nums))&#10;&#10;&#10;    def balance_tree(self, root: TreeNode) -&gt; TreeNode:&#10;        &quot;&quot;&quot; O(N)TS &quot;&quot;&quot;&#10;        tree_list = self.inorder_traversal_recursive_bottomup(root)&#10;        return self.sorted_array_to_balanced_tree(tree_list)&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;various methods&quot;&gt;&#10;    def is_valid_binary_search_tree(self, root: TreeNode) -&gt; bool:&#10;        &quot;&quot;&quot;  O(height of tree)T O(height of tree)S  &quot;&quot;&quot;&#10;&#10;        def helper(node, min_edge, max_edge):&#10;            if node is None:&#10;                return True&#10;&#10;            if not (min_edge &lt; node.val &lt; max_edge):&#10;                return False&#10;&#10;            if (node.left and node.val &lt;= node.left.val) or (node.right and node.val &gt;= node.right.val):&#10;                return False&#10;&#10;            return helper(node.left, min_edge, node.val) and helper(node.right, node.val, max_edge)&#10;&#10;        return helper(root, -math.inf, math.inf)&#10;&#10;    def inorder_successor(self, root: 'TreeNode', p: 'TreeNode') -&gt; 'TreeNode':&#10;        &quot;&quot;&quot; O(tree height)T O(1)S   find succ node&quot;&quot;&quot;&#10;        successor = None&#10;        # case 1. turn right, then left..left&#10;        if p.right:&#10;            node = p.right&#10;            while node:&#10;                successor = node&#10;                node = node.left&#10;        # case 2. ordinary search in bst&#10;        else:&#10;            node = root&#10;            while node:&#10;                if node.val == p.val:&#10;                    break&#10;                if p.val &gt; node.val:&#10;                    node = node.right&#10;                else:&#10;                    successor = node  # any root node, where root.left=..p..&#10;                    node = node.left&#10;&#10;        return successor&#10;&#10;    def max_depth(self, root: TreeNode) -&gt; int:&#10;        &quot;&quot;&quot; lever-order traversion, recursive bottom-up&quot;&quot;&quot;&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return level&#10;&#10;            return max(helper(node.left, level + 1), helper(node.right, level + 1))&#10;&#10;        return helper(root, 0)&#10;&#10;    pass  # &lt;/editor-fold&gt;&#10;&#10;T1, T2, T3, T4, T5 = TreeNode(4), TreeNode(2), TreeNode(7), TreeNode(1), TreeNode(3)&#10;T1.left, T1.right = T2, T3&#10;T2.left, T2.right = T4, T5&#10;wilmerlibrary.draw_binary_tree(T1)" description="Bimary Search Tree = binary tree" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TEMPLATE devide and conquer" value="def divide_and_conquer( S ):&#10;    # (1). Divide the problem into a set of subproblems.&#10;    [S1, S2, ... Sn] = divide(S)&#10;&#10;    # (2). Solve the subproblem recursively,&#10;    #   obtain the results of subproblems as [R1, R2... Rn].&#10;    rets = [divide_and_conquer(Si) for Si in [S1, S2, ... Sn]]&#10;    [R1, R2,... Rn] = rets&#10;&#10;    # (3). combine the results from the subproblems.&#10;    #   and return the combined result.&#10;    return combine([R1, R2,... Rn])" description="from LEETCODE" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TEMPLATE backtracking" value="def backtrack(candidate):&#10;    if find_solution(candidate):&#10;        output(candidate)&#10;        return&#10;    &#10;    # iterate all possible candidates.&#10;    for next_candidate in list_of_candidates:&#10;        if is_valid(next_candidate):&#10;            # try this partial candidate solution&#10;            place(next_candidate)&#10;            # given the candidate, explore further.&#10;            backtrack(next_candidate)&#10;            # backtrack&#10;            remove(next_candidate)" description="from LEETCODE" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TEMPLATE backtracking My" value="class Solution(object):&#10;    &quot;&quot;&quot;ok &quot;&quot;&quot;&#10;&#10;    def solve(self, data):&#10;        &quot;&quot;&quot; ok &quot;&quot;&quot;&#10;        busy_data = [False] * 10&#10;&#10;        solution_set = set()&#10;        solution_result = []&#10;&#10;        def is_found_solution(y):&#10;            &quot;&quot;&quot; в каждом вызове рекурсии  это шаг к окончательному решению, поэтому следует проверять получилось ли решение  &quot;&quot;&quot;&#10;            return True&#10;&#10;        def add_solution():&#10;            nonlocal solution_result&#10;&#10;            solution = solution_set&#10;            solution_result += [solution]&#10;&#10;        def is_valid(x, y):&#10;            &quot;&quot;&quot; prune - если шаг(те текущая рекурсия) не ведет к решению то по ней и не идем &quot;&quot;&quot;&#10;            if busy_data:&#10;                return False&#10;            return True&#10;&#10;        def place(x, y):&#10;            &quot;&quot;&quot;добавить узел в ветвь текущего варианта&quot;&quot;&quot;&#10;            nonlocal solution_set&#10;            solution_set |= {(x,y)}&#10;            busy_data[x] = True&#10;&#10;        def remove(x, y):&#10;            &quot;&quot;&quot; backtrack - удалить узел в ветви текущего варианта&#10;            &#10;            в конце рекурсивного шага мы должны откатиться на предыдущую ветвь &#10;            (например удалить текущую ветвь решения, если она отслеживается) &quot;&quot;&quot;&#10;            nonlocal solution_set&#10;            solution_set -= {(x, y)}&#10;            busy_data[x] = False&#10;&#10;        def backtrack(y):&#10;            &quot;&quot;&quot; внутри рекурсии мы итерируемся по всем кандидатам решения, например по всем листьям корневого узла &quot;&quot;&quot; &#10;            for x in range(n):&#10;            &#10;                if not is_valid(x, y):&#10;                    continue&#10;                place(x, y)&#10;               &#10;                if is_found_solution(y): &#10;                    add_solution()&#10;                else:&#10;                    backtrack(y + 1)&#10;                    &#10;                remove(x, y)&#10;&#10;        backtrack(0)&#10;        return solution_result" description="from My" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class binary search" value="class BinarySearch(object):&#10;    &quot;&quot;&quot; ok    &quot;&quot;&quot;&#10;&#10;    # &lt;editor-fold desc=&quot;exact search&quot;&gt;&#10;    def search_recursive(self, nums: List[int], target: int) -&gt; int:&#10;        &quot;&quot;&quot;SUPER [..) O(log N)T O(1)S. Usual search. &quot;&quot;&quot;&#10;&#10;        def helper(left, right):&#10;            if left &gt;= right:  # [left,right) поэтому правый индекс не может быть равен левому&#10;                return -1&#10;&#10;            mid = (right - left) // 2 + left&#10;            pivot = nums[mid]&#10;&#10;            if pivot == target:&#10;                return mid&#10;            if pivot &lt; target:&#10;                return helper(mid + 1, right)&#10;            else:&#10;                return helper(left, mid)&#10;&#10;        return helper(0, len(nums))&#10;&#10;    def search_recursive_love(self, nums: List[int], target: int) -&gt; int:&#10;        &quot;&quot;&quot;[..)  O(log N)T O(N)S. Usual search.&#10;&#10;        каждый раз передаю входные данные на вход рекурсии&#10;        &quot;&quot;&quot;&#10;&#10;        def helper(arr, idx):&#10;            if not arr:&#10;                return -1&#10;&#10;            idx_pivot = len(arr) // 2&#10;            left, mid, right = arr[:idx_pivot], arr[idx_pivot], arr[idx_pivot + 1:]&#10;&#10;            if mid == target:&#10;                return idx + idx_pivot&#10;            if mid &lt; target:&#10;                return helper(right, idx + idx_pivot + 1)  # +1 к индексцу так как пропускаем опорный элемент&#10;            else:&#10;                return helper(left, idx)&#10;&#10;        return helper(nums, 0)&#10;&#10;    def search_iterative(self, nums: List[int], target: int) -&gt; int:&#10;        &quot;&quot;&quot;SUPER [..) O(log N)T O(1)S. Usual search. &quot;&quot;&quot;&#10;        left, right = 0, len(nums)  # [..len)&#10;        while left &lt; right:  # [left,right) поэтому правый индекс не может быть равен левому&#10;            mid = (right - left) // 2 + left&#10;            pivot = nums[mid]&#10;            DEBUG = nums[left:mid], pivot, nums[mid + 1:right], left, right&#10;&#10;            if pivot == target:&#10;                return mid&#10;            if pivot &lt; target:&#10;                left = mid + 1&#10;            else:&#10;                right = mid  # [..mid)&#10;&#10;        DEBUG = left, right&#10;        return -1&#10;&#10;    def search_iterative_variant(self, nums: List[int], target: int) -&gt; int:&#10;        &quot;&quot;&quot;[..] диапазон. обычный поиск&quot;&quot;&quot;&#10;        left, right = 0, len(nums) - 1  # [..len-1]&#10;        while left &lt;= right:  # &lt;= для обычного бинарного поиска&#10;            mid = (right - left) // 2 + left&#10;            pivot, next_ = nums[mid], nums[mid]&#10;            DEBUG = nums[left:mid], pivot, nums[mid + 1:right + 1], left, right&#10;&#10;            if pivot == target:&#10;                return mid&#10;            if pivot &lt; target:&#10;                left = mid + 1&#10;            else:&#10;                right = mid - 1  # [..mid-1]&#10;&#10;        DEBUG = left, right&#10;        return -1&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;итерирую по два элемента - текущий и правый&quot;&gt;&#10;    def search_stepby2_recursive(self, nums: List[int], target: int) -&gt; int:&#10;        &quot;&quot;&quot;SUPER [..) O(log N)T O(1)S. итерируем по два элемента &quot;&quot;&quot;&#10;&#10;        def helper(left, right):&#10;            if left + 1 &gt;= right:  # +1 чтобы всегда в конце оставался один элемент&#10;                # самый правый жлмент остался необработан&#10;                if left != len(nums) and nums[left] == target:&#10;                    return left&#10;                return -1&#10;&#10;            mid = (right - left - 1) // 2 + left  # -1 чтобы сместился на первый элемент из двух&#10;            pivot, pivot_next = nums[mid], nums[mid + 1]&#10;            DEBUG = nums[left:mid], pivot, nums[mid + 1:right], left, right&#10;&#10;            if pivot == target:&#10;                return mid&#10;            if pivot &lt; target:&#10;                return helper(mid + 1, right)&#10;            else:&#10;                return helper(left, mid)&#10;&#10;        return helper(0, len(nums))&#10;&#10;    def search_stepby2_recursive_love(self, nums: List[int], target: int) -&gt; int:&#10;        &quot;&quot;&quot;[..)  O(log N)T O(N)S. итерируем по два элемента.&#10;&#10;        каждый раз передаю входные данные на вход рекурсии&#10;        &quot;&quot;&quot;&#10;&#10;        def helper(arr, idx):&#10;            if len(arr) &lt;= 1:  # 1 чтобы всегда в конце оставался один элемент&#10;                # самый правый жлмент остался необработан&#10;                if arr and arr[0] == target:&#10;                    return idx&#10;                return -1&#10;&#10;            mid = (len(arr) - 1) // 2  # -1 чтобы сместился на первый элемент из двух&#10;            left, pivot, right = arr[:mid], arr[mid], arr[mid + 1:]  # [..mid)[mid+1..)&#10;            pivot_next = arr[mid + 1]&#10;&#10;            if pivot == target:&#10;                return idx + mid&#10;            if pivot &lt; target:&#10;                return helper(right, idx + mid + 1)  # +1 к индексцу так как пропускаем опорный элемент&#10;            else:&#10;                return helper(left, idx)&#10;&#10;        return helper(nums, 0)&#10;&#10;    def search_stepby2_iterative(self, nums: List[int], target: int) -&gt; int:&#10;        &quot;&quot;&quot;SUPER [..) диапазон. итерируем по два элемента&quot;&quot;&quot;&#10;        left, right = 0, len(nums)  # [..len)&#10;        while left + 1 &lt; right:  # +1 чтобы всегда в конце оставался один элемент&#10;            mid = (right - left - 1) // 2 + left  # -1 чтобы сместился на первый элемент из двух&#10;            pivot, pivot_next = nums[mid], nums[mid + 1]  # [..mid)[mid+1..)&#10;            DEBUG = nums[left:mid], pivot, nums[mid + 1:right], left, right&#10;&#10;            if pivot == target:&#10;                return mid&#10;            if pivot &lt; target:&#10;                left = mid + 1&#10;            else:&#10;                right = mid  # [..mid)&#10;&#10;        # самый правый элмент остался необработан&#10;        DEBUG = left, right&#10;        if left != len(nums) and nums[left] == target:&#10;            return left&#10;        return -1&#10;&#10;    def search_stepby2_iterative_variant(self, nums: List[int], target: int) -&gt; int:&#10;        &quot;&quot;&quot;[..] диапазон. итерируем по два элемента&quot;&quot;&quot;&#10;        left, right = 0, len(nums) - 1  # [..len-1]&#10;        while left &lt; right:  # &lt;= для обычного бинарного поиска&#10;            mid = (right - left) // 2 + left&#10;            pivot, pivot_next = nums[mid], nums[mid + 1]&#10;            DEBUG = nums[left:mid], pivot, nums[mid + 1:right + 1], left, right&#10;&#10;            if pivot == target:&#10;                return mid&#10;            if pivot &lt; target:&#10;                left = mid + 1&#10;            else:&#10;                right = mid - 1  # [..mid-1]&#10;&#10;        # самый правый жлмент остался необработан&#10;        DEBUG = left, right&#10;        if left != len(nums) and nums[left] == target:&#10;            return left&#10;        return -1&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;итерирую по три элемента левый-текущий-правый&quot;&gt;&#10;    def search_stepby3_recursive(self, nums: List[int], target: int) -&gt; int:&#10;        &quot;&quot;&quot;SUPER [..) O(log N)T O(1)S. итерируем по два элемента &quot;&quot;&quot;&#10;        if not nums:  # такая проверка нужна только для случая stebby3&#10;            return -1&#10;&#10;        def helper(left, right):&#10;            if left + 2 &gt;= right:  # +1 чтобы всегда в конце оставались два элемента&#10;                # два элемента остались необработаны&#10;                if nums[left] == target:&#10;                    return left&#10;                if nums[right - 1] == target:  # [left right)&#10;                    return right - 1&#10;                return -1&#10;&#10;            mid = (right - left - 1) // 2 + left  # -1 чтобы сместился на первый элемент из двух&#10;            pivot_prev, pivot, pivot_next = nums[mid - 1], nums[mid], nums[mid + 1]&#10;            DEBUG = nums[left:mid], pivot, nums[mid + 1:right], left, right&#10;&#10;            if pivot == target:&#10;                return mid&#10;            if pivot &lt; target:&#10;                return helper(mid + 1, right)&#10;            else:&#10;                return helper(left, mid)&#10;&#10;        return helper(0, len(nums))&#10;&#10;    def search_stepby3_recursive_love(self, nums: List[int], target: int) -&gt; int:&#10;        &quot;&quot;&quot;[..)  O(log N)T O(N)S. итерируем по два элемента.&#10;&#10;        каждый раз передаю входные данные на вход рекурсии&#10;        &quot;&quot;&quot;&#10;        if not nums:  # такая проверка нужна только для случая stebby3&#10;            return -1&#10;&#10;        def helper(arr, idx):&#10;            if len(arr) &lt;= 2:  # 2 чтобы всегда в конце оставались два элемента&#10;                # два элемента остались необработаны&#10;                if arr[0] == target:&#10;                    return idx&#10;                if arr[1] == target:&#10;                    return idx + 1&#10;                return -1&#10;&#10;            mid = (len(arr) - 1) // 2  # -1 чтобы сместился на первый элемент из двух&#10;            left, pivot, right = arr[:mid], arr[mid], arr[mid + 1:]  # [..mid)[mid+1..)&#10;            pivot_prev, pivot_next = arr[mid - 1], arr[mid + 1]&#10;&#10;            if pivot == target:&#10;                return idx + mid&#10;            if pivot &lt; target:&#10;                return helper(right, idx + mid + 1)  # +1 к индексцу так как пропускаем опорный элемент&#10;            else:&#10;                return helper(left, idx)&#10;&#10;        return helper(nums, 0)&#10;&#10;    def search_stepby3_iterative(self, nums: List[int], target: int) -&gt; int:&#10;        &quot;&quot;&quot;SUPER [..) диапазон. итерируем по два элемента&quot;&quot;&quot;&#10;        if not nums:  # такая проверка нужна только для случая stebby3&#10;            return -1&#10;&#10;        left, right = 0, len(nums)  # [..len)&#10;        while left + 2 &lt; right:  # +2 чтобы всегда в конце оставались два элемента&#10;            mid = (right - left - 1) // 2 + left  # -1 чтобы сместился на первый элемент из двух&#10;            pivot_prev, pivot, pivot_next = nums[mid - 1], nums[mid], nums[mid + 1]  # [..mid)[mid+1..)&#10;            DEBUG = nums[left:mid], pivot, nums[mid + 1:right], left, right&#10;&#10;            if pivot == target:&#10;                return mid&#10;            if pivot &lt; target:&#10;                left = mid + 1&#10;            else:&#10;                right = mid  # [..mid)&#10;&#10;        # два элемента остались необработаны&#10;        DEBUG = left, right&#10;        if nums[left] == target:&#10;            return left&#10;        if nums[right - 1] == target:  # [left right)&#10;            return right - 1&#10;        return -1&#10;&#10;    def search_stepby3_iterative_variant(self, nums: List[int], target: int) -&gt; int:&#10;        &quot;&quot;&quot;[..] диапазон. итерируем по два элемента&quot;&quot;&quot;&#10;        if not nums:  # такая проверка нужна только для случая stebby3&#10;            return -1&#10;&#10;        left, right = 0, len(nums) - 1  # [..len-1]&#10;        while left + 2 &lt;= right:  # +2 чтобы всегда в конце оставались два элемента&#10;            mid = (right - left) // 2 + left&#10;            pivot_prev, pivot, pivot_next = nums[mid - 1], nums[mid], nums[mid + 1]&#10;&#10;            DEBUG = nums[left:mid], pivot, nums[mid + 1:right + 1], left, right&#10;&#10;            if pivot == target:&#10;                return mid&#10;            if pivot &lt; target:&#10;                left = mid + 1&#10;            else:&#10;                right = mid - 1  # [..mid-1]&#10;&#10;        # два элемента остались необработаны&#10;        DEBUG = left, right&#10;        if nums[left] == target:&#10;            return left&#10;        if nums[right] == target:&#10;            return right&#10;        return -1&#10;&#10;    pass  # &lt;/editor-fold&gt;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function CYCLE FIND v3 O(N)T O(1)Space" value="def findDuplicate(self, nums: List[int]) -&gt; int:&#10;    # (1) detect cycle&#10;    ptr_slow, ptr_fast = nums[0], nums[nums[0]] # каждый сделал один шаг&#10;    while ptr_slow != ptr_fast:&#10;        ptr_slow = nums[ptr_slow]&#10;        ptr_fast = nums[nums[ptr_fast]]&#10;&#10;    # (2) detect start cycle&#10;    ptr_slow, ptr_slow2 = 0, ptr_fast&#10;    while ptr_slow != ptr_slow2:&#10;        ptr_slow = nums[ptr_slow]&#10;        ptr_slow2 = nums[ptr_slow2]&#10;&#10;    return ptr_slow&#10;" description="Floyds алгоритм черепахи и зайца" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class N-ary tree" value="class Node(object):&#10;    &quot;&quot;&quot; N-ary tree node&#10;&#10;    - children всегда =[list] и проверять на пустоту в алгоритмах НЕ надо&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, x):&#10;        self.val = x&#10;        self.children = []&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;&#10;class NaryTree(object):&#10;    &quot;&quot;&quot; ok&#10;&#10;    - no standard definition for in-order traversal in n-ary trees&#10;    &quot;&quot;&quot;&#10;&#10;    # &lt;editor-fold desc=&quot;DFS pre order&quot;&gt;&#10;    def preorder_traversal_recursive_bottomup(self, node: Node) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER DFS O(N)ST tree pre-order traversal recursive(bottom-up)&#10;&#10;        children всегда =[list] и проверять на пустоту их ненадо&#10;        &quot;&quot;&quot;&#10;        if not node:&#10;            return []&#10;&#10;        trees = []&#10;        for child in node.children:&#10;            trees += self.preorder_traversal_recursive_bottomup(child)&#10;&#10;        return [node.val] + trees&#10;&#10;    def preorder_traversal_recursive_topdown(self, root: Node) -&gt; List[int]:&#10;        &quot;&quot;&quot; DFS O(N)ST tree pre-order traversal recursive(top-down)&#10;&#10;        children всегда =[list] и проверять на пустоту их ненадо&#10;        &quot;&quot;&quot;&#10;        traverse = []&#10;&#10;        def helper(node):&#10;            nonlocal traverse&#10;            if not node:&#10;                return&#10;&#10;            traverse += [node.val]&#10;            for child in node.children:&#10;                helper(child)&#10;&#10;        helper(root)&#10;        return traverse&#10;&#10;    def preorder_traversal_iterative(self, root: Node) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER DFS O(N)ST tree pre-order traversal&#10;&#10;        children всегда =[list] и проверять на пустоту их ненадо&#10;        &quot;&quot;&quot;&#10;        stack = [root]&#10;        while node := stack.pop() if stack else None:&#10;            yield node.val  # main work&#10;&#10;            stack += node.children[::-1]  # :-1 чтобы первый ребенок выбрали первым&#10;&#10;    def preorder_traversal_iterative2(self, root: Node) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER DFS O(N)ST tree pre-order traversal&#10;&#10;        - допускаются None элементы в стэке&#10;        - children всегда =[list] и проверять на пустоту их ненадо&#10;        &quot;&quot;&quot;&#10;        stack = [root]&#10;        while stack:&#10;            node = stack.pop()&#10;            if node is None:&#10;                continue&#10;            yield node.val  # main work&#10;&#10;            stack += node.children[::-1]  # :-1 чтобы первый ребенок выбрали первым&#10;&#10;    def preorder_traversal_iterative_variant(self, root: Node) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)ST DFS tree pre-order traversal&#10;&#10;        - children всегда =[list] и проверять на пустоту их ненадо&#10;        &quot;&quot;&quot;&#10;        result = []&#10;&#10;        stack = [root]&#10;        while node := stack.pop() if stack else None:&#10;            result += [node.val]  # main work&#10;&#10;            stack += node.children[::-1]  # :-1 чтобы первый ребенок выбрали первым&#10;&#10;        return result&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;DFS post order&quot;&gt;&#10;    def postorder_traversal_recursive_bottomup(self, node: Node) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree post-order traversal recursive(bottom-up)&#10;&#10;        children всегда =[list] и проверять на пустоту их ненадо&#10;        &quot;&quot;&quot;&#10;        if not node:&#10;            return []&#10;&#10;        trees = []&#10;        for child in node.children:&#10;            trees += self.postorder_traversal_recursive_bottomup(child)&#10;&#10;        return trees + [node.val]&#10;&#10;    def postorder_traversal_recursive_topdown(self, root: Node) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)ST tree post-order traversal recursive(top-down)&#10;&#10;        children всегда =[list] и проверять на пустоту их ненадо&#10;        &quot;&quot;&quot;&#10;        traverse = []&#10;&#10;        def helper(node):&#10;            nonlocal traverse&#10;            if not node:&#10;                return&#10;&#10;            for child in node.children:&#10;                helper(child)&#10;            traverse += [node.val]&#10;&#10;        helper(root)&#10;        return traverse&#10;&#10;    def postorder_traversal_iterative(self, root: Node) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree post-order traversal &quot;&quot;&quot;&#10;&#10;        return list(self.preorder_traversal_iterative(root))[::-1]&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;BFS level order&quot;&gt;&#10;    def levelorder_traversal_iterative(self, root: Node) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal&#10;&#10;        children всегда =[list] и проверять на пустоту их ненадо&#10;        &quot;&quot;&quot;&#10;        queue = collections.deque([root])&#10;        while node := queue.pop() if queue else None:&#10;            yield node.val  # main work&#10;&#10;            queue.extendleft(node.children)&#10;&#10;    def levelorder_traversal_recursive_topdown(self, root: Node) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal recursive(top-down)&quot;&quot;&quot;&#10;        levels = collections.defaultdict(list)&#10;        if not root:&#10;            return levels.values()&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return&#10;            levels[level] += [node.val]&#10;            for child in node.children:&#10;                helper(child, level + 1)&#10;&#10;        helper(root, 0)&#10;&#10;        # значения будут складываться в словарь в порядке обхода слоями, поэтому ненужна сортировка по level&#10;        return itertools.chain.from_iterable(levels.values())&#10;&#10;    def levelorder_traversal_recursive_bottomup(self, root: Node) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot; BFS O(N)ST tree level-order traversal recursive(bottom up)&quot;&quot;&quot;&#10;        if not root:&#10;            return []&#10;&#10;        def group_dicts(*dicts):&#10;            &quot;&quot;&quot; group_dicts(map1, map2, map3)&quot;&quot;&quot;&#10;            items = [d.items() for d in dicts]&#10;            merged = collections.defaultdict(list)&#10;            for key, value in itertools.chain.from_iterable(items):&#10;                merged[key] += value&#10;            return merged&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return {}&#10;&#10;            level_node = {&#10;                level: [node.val]&#10;            }&#10;&#10;            dicts = [helper(child, level + 1) for child in node.children] + [level_node]&#10;            return group_dicts(*dicts)&#10;&#10;        levels = helper(root, 0).items()&#10;        levels_sorted = sorted(levels)&#10;        levels_vals = [value for key, value in levels_sorted]&#10;        return itertools.chain.from_iterable(levels_vals)&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;BFS level order with levelNum&quot;&gt;&#10;    def levelorder_traversal_recursive_withlevelnum(self, root: Node) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal &quot;&quot;&quot;&#10;        levels = collections.defaultdict(list)&#10;        if not root:&#10;            return levels.values()&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return&#10;            levels[level] += [node.val]&#10;            for child in node.children:&#10;                helper(child, level + 1)&#10;&#10;        helper(root, 0)&#10;&#10;        return levels.values()&#10;&#10;    def levelorder_traversal_iterative_withlevelnum_var1(self, root: Node) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal&#10;&#10;        суперподход: запихнуть вместе с нодой в стек дополнительную информацию&#10;        те в стеке кортеж (нода, значение)&#10;&#10;        stack based&#10;        &quot;&quot;&quot;&#10;        levels = collections.defaultdict(list)&#10;&#10;        stack = [(1, root)] if root else None  # проверка на пустоту&#10;        while stack:&#10;            level, node = stack.pop()&#10;            levels[level] += [node.val]&#10;            stack += [(level + 1, child) for child in reversed(node.children)]  # reversed так как из стека будем забирать от последнего&#10;&#10;        return levels.values()&#10;&#10;    def levelorder_traversal_iterative_withlevelnum_var1b(self, root: Node) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot; BFS O(N)ST tree level-order traversal&#10;&#10;        queue based&#10;        &quot;&quot;&quot;&#10;        levels = collections.defaultdict(list)&#10;&#10;        queue = collections.deque([(1, root)]) if root else None  # проверка на пустоту&#10;        while queue:&#10;            level, node = queue.pop()&#10;            levels[level] += [node.val]&#10;&#10;            queue.extendleft((level + 1, child) for child in node.children)&#10;&#10;        return levels.values()&#10;&#10;    def levelorder_traversal_iterative_withlevelnum_var2(self, root: Node) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot; BFS O(N)ST tree level-order traversal&#10;&#10;        принцип комплиментарности&#10;&#9;    - выберем справа все ноды данного уровня , все равно добавлять ноды будем с другого конца,&#10;&#9;    поэтому они не смешаются (и я случайно не выберу только что добавленную ноду)&#10;        после добавления всех нод (и удаления всех нод текущего уровня) = это и есть ноды следующего уровня&#10;&#10;        - после исчерпывания нод во внутреннем цикле for мы собираем цровень целиком&#10;        &quot;&quot;&quot;&#10;&#10;        queue = collections.deque([root]) if root else None  # проверка на пустоту&#10;        while queue:&#10;            level, level_len = [], len(queue)&#10;&#10;            for _ in range(level_len):  # из всех нод находящихся сейчас в стеке собираем уровень&#10;                node = queue.pop()&#10;                level += [node.val]&#10;                queue.extendleft(node.children)  # все равно добавлять ноды будем с другого конца, поэтому они не смешаются&#10;&#10;            yield level&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;various methods&quot;&gt;&#10;    def max_depth(self, root: Node) -&gt; int:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; lever-order traversion, recursive bottom-up&quot;&quot;&quot;&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return level&#10;&#10;            if not node.children:  # на тот случай если детей нет а нода есть&#10;                return level + 1&#10;&#10;            return max(helper(child, level + 1) for child in node.children)&#10;&#10;        return helper(root, 0)&#10;&#10;    VISIBLE = 48&#10;&#10;    def serialize(self, root: 'Node') -&gt; str:&#10;        &quot;&quot;&quot;Encodes a tree to a single string.&#10;&#10;        :type root: Node&#10;        :rtype: str&#10;        &quot;&quot;&quot;&#10;&#10;        def helper(node):&#10;            if not node:&#10;                return &quot;&quot;&#10;&#10;            trees = &quot;&quot;&#10;            for child in node.children:&#10;                trees += helper(child)&#10;&#10;            return chr(node.val + self.VISIBLE) + trees + &quot;#&quot;&#10;&#10;        return helper(root)&#10;&#10;    def deserialize(self, data: str) -&gt; 'Node':&#10;        &quot;&quot;&quot;Decodes your encoded data to tree.&#10;&#10;        :type data: str&#10;        :rtype: Node&#10;        &quot;&quot;&quot;&#10;        tree_str = list(reversed(list(data)))&#10;&#10;        def helper():&#10;            nonlocal tree_str&#10;&#10;            if not tree_str:&#10;                return None&#10;&#10;            if tree_str[-1] == &quot;#&quot;:&#10;                tree_str.pop()&#10;                return None&#10;&#10;            node_str = tree_str.pop()&#10;            root_node = Node(ord(node_str) - self.VISIBLE)&#10;&#10;            while node := helper():&#10;                root_node.children += [node]&#10;&#10;            return root_node&#10;&#10;        return helper()&#10;&#10;&#10;    pass  # &lt;/editor-fold&gt;&#10;&#10;&#10;T1, T2, T3, T4, T5, T6 = Node(1), Node(2), Node(3), Node(4), Node(5), Node(6)&#10;T1.children = [T3, T2, T4]&#10;T3.children = [T5, T6]&#10;&#10;wilmerlibrary.draw_n_ary_tree(T1)" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class trie" value="class TrieNode(object):&#10;    &quot;&quot;&quot; Trie node &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.children = {}&#10;        self.is_end = False&#10;&#10;    def __repr__(self):&#10;        return str(&quot;&quot;.join(self.children.keys()) + &quot;!&quot; if self.is_end else &quot;..&quot;)&#10;&#10;class Trie(object):&#10;    &quot;&quot;&quot; prefix tree&#10;&#10;    O(число_слов * макс_размер_слов * число_букв_в_словаре)S - умножаем на длину алфавита так как каждая нода содержит словарь&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.trie = TrieNode()&#10;&#10;    # &lt;editor-fold desc=&quot;CRUD&quot;&gt;&#10;    def search_iterative(self, word: str) -&gt; bool:&#10;        &quot;&quot;&quot; SUPER. Returns if the word is in the trie.&#10;&#10;        O(len word)T, because of HasnMap.&#10;        O(1)S&#10;        &quot;&quot;&quot;&#10;        node = self.trie&#10;        for sym in word:&#10;            node = node.children.get(sym)&#10;            if not node:  # если дальше нет подходящих ребер&#10;                return False&#10;        return node.is_end&#10;&#10;    def search_recursive(self, word: str) -&gt; bool:&#10;        &quot;&quot;&quot; Returns if the word is in the trie.&#10;&#10;        O(len word)T, because of HasnMap.&#10;        O(len word)S, because recursion&#10;        &quot;&quot;&quot;&#10;&#10;        def search(node, word_list):&#10;            if not word_list:  # если это последняя-нода полследней-буквы-слова&#10;                return node.is_end&#10;&#10;            sym, *word_last = word_list&#10;            node_next = node.children.get(sym)&#10;&#10;            if not node_next:  # если дальше нет подходящих ребер&#10;                return False&#10;&#10;            return search(node_next, word_last)&#10;&#10;        return search(self.trie, list(word))&#10;&#10;    def insert_iterative(self, word: str) -&gt; None:&#10;        &quot;&quot;&quot; SUPER. Returns if the word is in the trie.&#10;&#10;        O(len word)T, because of HasnMap.&#10;        O(len word)S, если это абсолютно новое слово, у которого нет еще разделяемого префикса&#10;        &quot;&quot;&quot;&#10;        node = self.trie&#10;        for sym in word:&#10;            if sym not in node.children:&#10;                node.children[sym] = TrieNode()&#10;&#10;            node = node.children[sym]&#10;&#10;        node.is_end = True&#10;        return&#10;&#10;    def insert_recursive(self, word: str) -&gt; None:&#10;        &quot;&quot;&quot; Inserts a word into the trie.&#10;&#10;        O(len word)T, because of HasnMap.&#10;        O(len word)S, because recursion and если это абсолютно новое слово, у которого нет еще разделяемого префикса&#10;        &quot;&quot;&quot;&#10;&#10;        def search(node, word_list):&#10;            if not word_list:  # если это последняя-нода полследней-буквы-слова&#10;                return node, word_list&#10;&#10;            sym, *word_last = word_list&#10;            node_next = node.children.get(sym)&#10;&#10;            if not node_next:  # если дальше нет подходящих ребер&#10;                return node, word_list  # список не изменился&#10;&#10;            return search(node_next, word_last)&#10;&#10;        def append(node, word_list):&#10;            if not word_list:&#10;                node.is_end = True&#10;                return&#10;&#10;            sym, *word_last = word_list&#10;            node_new = node.children[sym] = TrieNode()&#10;            append(node_new, word_last)&#10;&#10;        node_end, word_list = search(self.trie, list(word))&#10;        append(node_end, word_list)&#10;&#10;    def delete_iterative(self, word):&#10;        &quot;&quot;&quot; SUPER. прием: пока идем вдоль пути запомнить развилку  &quot;&quot;&quot;&#10;&#10;        node, is_delete, del_after_the_node = self.trie, True, lambda: self.trie.children.__delitem__(word[0])  # удалим после корня, если разветвлений вдруг не будет&#10;        for sym in word:&#10;            if len(node.children) &gt; 1 or node.is_end:  # найдем последнюю ноду разветвитель в пути&#10;                del_after_the_node = lambda s=sym, n=node: n.children.__delitem__(s)&#10;            node = node.children.get(sym)&#10;            if not node:  # если дальше нет подходящих ребер&#10;                return False&#10;&#10;        if not node.is_end:  # если последняя нода неключевая&#10;            return False&#10;&#10;        del_after_the_node()  # pattern command&#10;        return True&#10;&#10;    def delete_recursive(self, word):&#10;        &quot;&quot;&quot; O(len word)ST&#10;&#10;        - метод основан на search tree.&#10;        &quot;&quot;&quot;&#10;&#10;        def helper(node, word_list):&#10;            if not word_list:&#10;                return node.is_end  # если последняя нода-ключ, то значит нашли слово и его удаляем&#10;&#10;            sym, *word_last = word_list&#10;            node_next = node.children.get(sym)&#10;&#10;            if sym not in node.children:  # если далее нод нет а слово еще не исчерпалось&#10;                return False&#10;&#10;            is_del = helper(node_next, word_last)&#10;            if is_del:&#10;                del node.children[sym]  # удалим только одного ребенка, а детей может быть много&#10;&#10;            return (not node.is_end) and is_del and (not node.children)  # если вулючено удаление и текущая нода не ключевая и теперь уже без детей(после удаления последнего ребенка)&#10;&#10;        return helper(self.trie, list(word))&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;other methods&quot;&gt;&#10;    def longest_prefix(self, word):&#10;        node = self.trie&#10;        last_tie = None&#10;        temp_prefix = []&#10;        for sym in word:&#10;            if node.is_end:  # найдем последнюю ноду разветвитель в пути&#10;                last_tie = &quot;&quot;.join(temp_prefix)&#10;            temp_prefix += [sym]&#10;&#10;            node = node.children.get(sym)&#10;            if not node:  # если дальше нет подходящих ребер&#10;                return last_tie&#10;&#10;        if node.is_end:  # найдем последнюю ноду разветвитель в пути&#10;            last_tie = &quot;&quot;.join(temp_prefix)&#10;&#10;        return last_tie&#10;&#10;    def shortest_prefix(self, word):&#10;        node = self.trie&#10;        first_tie = False&#10;        temp_prefix = []&#10;        for sym in word:&#10;            if node.is_end and not first_tie:  # найдем последнюю ноду разветвитель в пути&#10;                first_tie = &quot;&quot;.join(temp_prefix)&#10;            temp_prefix += [sym]&#10;&#10;            node = node.children.get(sym)&#10;            if not node:  # если дальше нет подходящих ребер&#10;                return first_tie&#10;&#10;        if node.is_end:  # найдем последнюю ноду разветвитель в пути&#10;            last_tie = &quot;&quot;.join(temp_prefix)&#10;&#10;        return first_tie&#10;&#10;    def keys_starting_with(self, word):&#10;        &quot;&quot;&quot; ok &quot;&quot;&quot;&#10;        keys = []&#10;&#10;        def search(node, word_list):&#10;            if not word_list:  # если это последняя-нода полследней-буквы-слова&#10;                return node&#10;&#10;            sym, *word_last = word_list&#10;            node_next = node.children.get(sym)&#10;&#10;            if not node_next:  # если дальше нет подходящих ребер&#10;                return None  # список не изменился&#10;&#10;            return search(node_next, word_last)&#10;&#10;        def traversal(node, word):&#10;            nonlocal keys&#10;            if node.is_end:&#10;                keys += [&quot;&quot;.join(word)]&#10;&#10;            for sym, child in node.children.items():&#10;                traversal(child, word + [sym])&#10;&#10;        node_end = search(self.trie, list(word))&#10;        if node_end:&#10;            traversal(node_end, list(word))&#10;        return keys&#10;&#10;    def search_node(self, word: str) -&gt; bool:&#10;        &quot;&quot;&quot; SUPER. Returns last node (key or not key)&#10;&#10;        O(len word)T, because of HasnMap.&#10;        O(1)S&#10;        &quot;&quot;&quot;&#10;        node = self.trie&#10;        for sym in word:&#10;            node = node.children.get(sym)&#10;            if not node:  # если дальше нет подходящих ребер&#10;                return None&#10;        return node if node != self.trie else None&#10;&#10;    pass  # &lt;/editor-fold&gt;&#10;&#10;&#10;&#10;&#10;obj = Trie()&#10;obj.insert_iterative(&quot;vovan&quot;)&#10;obj.insert_iterative(&quot;volk&quot;)&#10;obj.insert_iterative(&quot;vov&quot;)&#10;&#10;print(obj.longest_prefix(&quot;vova&quot;))&#10;wilmerlibrary.draw_trie(obj.trie)&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class graph SUPER" value="class Node(object):&#10;    &quot;&quot;&quot; N-ary tree node&#10;&#10;    - children всегда =[list] и проверять на пустоту в алгоритмах НЕ надо&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, x):&#10;        self.val = x&#10;        self.children = []&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;        &#10;&#10;class Graph(object):&#10;    &quot;&quot;&quot; work with graph methods&#10;&#10;    1) graph as N-ary tree with Node&#10;    2) graph as adjacency list&#10;    &quot;&quot;&quot;&#10;&#10;    # &lt;editor-fold desc=&quot;DFS pre order&quot;&gt;&#10;    def preorder_traversal_iterative(self, root: Node) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER DFS O(N)ST tree pre-order traversal&#10;&#10;        - children всегда =[list] и проверять на пустоту их ненадо&#10;        - вариант, где заносим в seen при занесении в стек&#10;        &quot;&quot;&quot;&#10;        stack, seen = [root], {root}&#10;        while node := stack.pop() if stack else None:&#10;            yield node.val  # main work&#10;&#10;            stack += [child for child in reversed(node.children) if child not in seen]  # :-1 чтобы первый ребенок выбрали первым&#10;            seen |= set(node.children)&#10;&#10;    def preorder_traversal_recursive_bottomup(self, root: Node) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER DFS O(N)ST tree pre-order traversal recursive(bottom-up)&#10;&#10;        - children всегда =[list] и проверять на пустоту их ненадо&#10;        - вариант, где заносим в seen при занесении в стек&#10;        &quot;&quot;&quot;&#10;        seen = set()&#10;&#10;        def helper(node):&#10;            nonlocal seen&#10;            if not node or node in seen:&#10;                return []&#10;            seen |= {node}&#10;&#10;            trees = []&#10;            for child in node.children:&#10;                trees += helper(child)&#10;&#10;            return [node.val] + trees&#10;&#10;        return helper(root)&#10;&#10;    def preorder_traversal_iterative_adjacencylist(self, graph: List) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER DFS O(N)ST tree pre-order traversal&#10;&#10;        - children всегда =[list] и проверять на пустоту их ненадо&#10;        - вариант, где заносим в seen при занесении в стек&#10;        &quot;&quot;&quot;&#10;        stack, seen = [0], {0}&#10;        while (node := stack.pop()) is not None if stack else None:  # is None нужно сделать явную проверку, так как номер первой вершины может быть 0&#10;            yield node  # main work&#10;&#10;            stack += [child for child in graph[node] if child not in seen]  # :-1 чтобы первый ребенок выбрали первым&#10;            seen |= set(graph[node])&#10;&#10;    def preorder_traversal_recursive_bottomup_adjacencylist(self, graph: List) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER DFS O(N)ST tree pre-order traversal recursive(bottom-up)&#10;&#10;        - children всегда =[list] и проверять на пустоту их ненадо&#10;        - вариант, где заносим в seen при занесении в стек&#10;        &quot;&quot;&quot;&#10;        seen = set()&#10;&#10;        def helper(node):&#10;            nonlocal seen&#10;            if node is None or node in seen:  # is None нужно сделать явную проверку, так как номер первой вершины может быть 0&#10;                return []&#10;            seen |= {node}&#10;&#10;            trees = []&#10;            for child in graph[node]:&#10;                trees += helper(child)&#10;&#10;            return [node] + trees&#10;&#10;        return helper(0)&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;DFS pre order | for Dijkstra  (no recursive verison)&quot;&gt;&#10;    def preorder_traversal_iterative_fordijkstra(self, root: Node) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot; DFS O(N)ST tree pre-order traversal&#10;&#10;        - children всегда =[list] и проверять на пустоту их ненадо&#10;        - вариант, где заносим в seen при обработке элемента (! В СТЕКЕ МОГУТ БЫТЬ ДУБЛИ ВЕРШИН !)&#10;        &quot;&quot;&quot;&#10;        stack, seen = [root], set()&#10;        while node := stack.pop() if stack else None:&#10;            yield node.val  # main work&#10;            seen |= {node}&#10;&#10;            stack += [child for child in reversed(node.children) if child not in seen]  # :-1 чтобы первый ребенок выбрали первым&#10;&#10;    def preorder_traversal_iterative_adjacencylist_fordijkstra(self, graph: List) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER DFS O(N)ST tree pre-order traversal&#10;&#10;        - children всегда =[list] и проверять на пустоту их ненадо&#10;        - вариант, где заносим в seen при обработке элемента  (! В СТЕКЕ МОГУТ БЫТЬ ДУБЛИ ВЕРШИН !)&#10;        &quot;&quot;&quot;&#10;        stack, seen = [0], set()&#10;        while (node := stack.pop()) is not None if stack else None:  # is None нужно сделать явную проверку, так как номер первой вершины может быть 0&#10;            yield node  # main work&#10;            seen |= {node}&#10;&#10;            stack += [child for child in graph[node] if child not in seen]  # :-1 чтобы первый ребенок выбрали первым&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;BFS level order&quot;&gt;&#10;    def levelorder_traversal_iterative(self, root: Node) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal&#10;&#10;        - children всегда =[list] и проверять на пустоту их ненадо&#10;        - вариант, где заносим в seen при занесении в стек&#10;        &quot;&quot;&quot;&#10;        queue, seen = collections.deque([root]), {root}&#10;        while node := queue.pop() if queue else None:&#10;            yield node.val  # main work&#10;&#10;            queue.extendleft([child for child in node.children if child not in seen])&#10;            seen |= set(node.children)&#10;&#10;    def levelorder_traversal_recursive_topdown(self, root: Node) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal recursive(top-down)&#10;&#10;        - вариант, где заносим в seen при занесении в стек&#10;        &quot;&quot;&quot;&#10;        levels, seen = collections.defaultdict(list), set()&#10;&#10;        if not root:&#10;            return levels.values()&#10;&#10;        def helper(node, level):&#10;            nonlocal seen&#10;            if not node or node in seen:&#10;                return&#10;            seen |= {node}&#10;&#10;            levels[level] += [node.val]&#10;&#10;            for child in node.children:&#10;                helper(child, level + 1)&#10;&#10;        helper(root, 0)&#10;&#10;        # значения будут складываться в словарь в порядке обхода слоями, поэтому ненужна сортировка по level&#10;        return itertools.chain.from_iterable(levels.values())&#10;&#10;    def levelorder_traversal_iterative_adjacencylist(self, graph: List) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal&#10;&#10;        - children всегда =[list] и проверять на пустоту их ненадо&#10;        - вариант, где заносим в seen при занесении в стек&#10;        &quot;&quot;&quot;&#10;        queue, seen = collections.deque([0]), {0}&#10;        while (node := queue.pop()) is not None if queue else None:  # is None нужно сделать явную проверку, так как номер первой вершины может быть 0&#10;            yield node  # main work&#10;&#10;            queue.extendleft([child for child in graph[node] if child not in seen])&#10;            seen |= set(graph[node])&#10;&#10;    def levelorder_traversal_recursive_topdown_adjacencylist(self, graph: List) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal recursive(top-down)&#10;&#10;        - вариант, где заносим в seen при занесении в стек&#10;        &quot;&quot;&quot;&#10;        levels, seen = collections.defaultdict(list), set()&#10;&#10;        if not graph:&#10;            return levels.values()&#10;&#10;        def helper(node, level):&#10;            nonlocal seen&#10;            if node is None or node in seen:  # is None нужно сделать явную проверку, так как номер первой вершины может быть 0&#10;                return []&#10;            seen |= {node}&#10;&#10;            levels[level] += [node]&#10;&#10;            for child in graph[node]:&#10;                helper(child, level + 1)&#10;&#10;        helper(0, 0)&#10;&#10;        # значения будут складываться в словарь в порядке обхода слоями, поэтому ненужна сортировка по level&#10;        return itertools.chain.from_iterable(levels.values())&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;various methods&quot;&gt;&#10;    pass&#10;    # &lt;/editor-fold&gt;&#10;    pass&#10;&#10;&#10;pass&#10;&#10;&#10;T0, T1, T2, T3, T4, T5, T6 = Node(0), Node(1), Node(2), Node(3), Node(4), Node(5), Node(6)&#10;T0.children = [T1, T2]&#10;T1.children = [T2, T3]&#10;T2.children = [T3]&#10;# wilmerlibrary.draw_graph_nodetree(T0)&#10;&#10;graph_directed = [[1, 2], [2, 3], [3], []]&#10;graph_directed2 = [[1, 2], [3], [1, 3], []]&#10;wilmerlibrary.draw_graph_adjacency_list(graph_directed)&#10;pass  # print(&quot;traveral&quot;, list(Graph().preorder_traversal_iterative(T0)))  # print(&quot;traveral&quot;, list(Graph().preorder_traversal_recursive_bottomup(T0)))  # print(&quot;traveral&quot;, list(Graph().preorder_traversal_iterative_adjacencylist(graph_directed)))&#10;# print(&quot;traveral&quot;, list(Graph().preorder_traversal_recursive_bottomup_adjacencylist(graph_directed)))&#10;# print(&quot;traveral&quot;, list(Graph().preorder_traversal_iterative_fordijkstra(T0)))&#10;# print(&quot;traveral&quot;, list(Graph().preorder_traversal_iterative_adjacencylist_fordijkstra(graph_directed2)))&#10;# print(&quot;traveral&quot;, list(Graph().levelorder_traversal_iterative(T0)))&#10;# print(&quot;traveral&quot;, list(Graph().levelorder_traversal_recursive_topdown(T0)))&#10;# print(&quot;traveral&quot;, list(Graph().levelorder_traversal_iterative_adjacencylist(graph_directed)))&#10;# print(&quot;traveral&quot;, list(Graph().levelorder_traversal_recursive_topdown_adjacencylist(graph_directed)))" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
</templateSet>