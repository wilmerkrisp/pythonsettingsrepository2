<templateSet group="_ALGO_v3_leetcode">
  <template name="map new list+dict. RandomizedSet" value="class RandomizedSet(object):&#10;    &quot;&quot;&quot; structure which provides the following operations in average O(1)  time: Insert Delete GetRandom&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        &quot;&quot;&quot; Initialize your data structure here.&#10;&#10;        -  list and dictionary for the same items are supported at the same time&#10;        -  aka indexed dictionary&#10;        &quot;&quot;&quot;&#10;        self.list = []&#10;        self.dict = {}&#10;&#10;    def insert(self, val: int) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Inserts a value to the set. Returns true if the set did not already contain the specified element.&#10;        &quot;&quot;&quot;&#10;        if val in self.dict:&#10;            return False&#10;&#10;        self.dict[val] = len(self.list)&#10;        self.list += [val]&#10;        return True&#10;&#10;    def remove(self, val: int) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Removes a value from the set. Returns true if the set contained the specified element.&#10;        &quot;&quot;&quot;&#10;        if (idx := self.dict.get(val)) is None:&#10;            return False&#10;&#10;        # swap last and deleted element&#10;        def swap(i, j):&#10;            self.list[i], self.list[j] = self.list[j], self.list[i]&#10;&#10;        swap(idx, -1)&#10;        self.dict[self.list[idx]] = idx&#10;&#10;        # delete from the end&#10;        self.list.pop()&#10;        del self.dict[val]&#10;        return True&#10;&#10;    def get_random(self) -&gt; int:&#10;        &quot;&quot;&quot;&#10;        Get a random element from the set.&#10;        &quot;&quot;&quot;&#10;        return random.choice(self.list)" description="O(1) inserte delete getRandom" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new COUNTER find duplicated elements" value="list_dups = [num for num, cnt in $collections$.Counter(nums).items() if cnt &gt; 1]" description="[ Counter(nums)  if cnt &gt; 1]" toReformat="false" toShortenFQNames="true">
    <variable name="collections" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE LU last updated" value="class LastUpdatedOrderedDict(collections.OrderedDict):&#10;    &quot;&quot;&quot; Store items in the order the keys were last added &quot;&quot;&quot;&#10;&#10;    def __setitem__(self, key, value):&#10;        super().__setitem__(key, value)&#10;        self.move_to_end(key)&#10;&#10; " description="OrderedDict" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE FIXEDSIZE LIFOqueue" value="class FixedSizeDict(collections.OrderedDict):&#10;    &quot;&quot;&quot; Limit size, evicting the LIFOqueue key when full &quot;&quot;&quot;&#10;&#10;    def __init__(self, maxsize=128, /, *args, **kwds):&#10;        self.maxsize = maxsize&#10;        super().__init__(*args, **kwds)&#10;&#10;    def __setitem__(self, key, value):&#10;        super().__setitem__(key, value)&#10;        if len(self) &gt; self.maxsize:&#10;            oldest = next(iter(self))&#10;            del self[oldest]&#10;&#10; " description="OrderedDict  размер кэша можно ограничить" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE  LRU Least recently used FIXEDSIZE v1" value="class LRU(collections.OrderedDict):&#10;    &quot;&quot;&quot; Limit size, evicting the least recently looked-up key when full &quot;&quot;&quot;&#10;&#10;    def __init__(self, maxsize=128, /, *args, **kwds):&#10;        self.maxsize = maxsize&#10;        super().__init__(*args, **kwds)&#10;&#10;    def __getitem__(self, key):&#10;        value = super().__getitem__(key)&#10;        self.move_to_end(key)&#10;        return value&#10;&#10;    def __setitem__(self, key, value):&#10;        super().__setitem__(key, value)&#10;        if len(self) &gt; self.maxsize:&#10;            oldest = next(iter(self))&#10;            del self[oldest]&#10;&#10; " description="OrderedDict  размер кэша можно ограничить" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list SWAP elements in list" value="def swap(i, j):&#10;    $arr$[i], $arr$[j] = $arr$[j], $arr$[i]" description="" toReformat="false" toShortenFQNames="true">
    <variable name="arr" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list QUEUE FIXEDSIZE с вытеснением" value="queue_=[]&#10;queue_[:0] = [12]   # push=enque&#10;v = queue_.pop()    # pop =deque&#10;&#10;dec = collections.deque([1, 2, 3, 4, 5, 6], maxlen=6)&#10;dec.appendleft(101)  # если добавить слева то вытеснится справа&#10;# [101, 1, 2, 3, 4, 5]&#10;dec.append(102) # если добавить справа то вытеснится слева&#10;# [1, 2, 3, 4, 5, 102]" description="deque(maxlen)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="list HEAP SUPER with deletion operation" value="class Heap():&#10;    &quot;&quot;&quot; Heap - priority queue.&#10;&#10;    Each element is a tuple (key,value)&#10;    &quot;&quot;&quot;&#10;&#10;    REMOVED = '&lt;removed-task&gt;'  # placeholder for a removed task&#10;&#10;    def __init__(self, list_):  # type: (Heap, Iterable) -&gt; None&#10;        self.heap = list(list_) if list_ else []  # list of entries arranged in a heap&#10;        self.entry_finder = {e[1]: e for e in self.heap}  # mapping of VALUES to entries&#10;        heapq.heapify(self.heap)&#10;&#10;    def push(self, key, value):  # type: (Heap, Any, Hashable) -&gt; None&#10;        &quot;&quot;&quot;Add a new VALUE or update the priority of an existing entry&quot;&quot;&quot;&#10;        if value in self.entry_finder:&#10;            self.remove(value)&#10;        entry = [key, value]&#10;        self.entry_finder[value] = entry&#10;        heapq.heappush(self.heap, entry)&#10;&#10;    def remove(self, value):  # type: (Heap, Hashable) -&gt; None&#10;        &quot;&quot;&quot;Mark an existing VALUE as REMOVED.  Raise KeyError if not found.&quot;&quot;&quot;&#10;        entry = self.entry_finder.pop(value)&#10;        entry[-1] = Heap.REMOVED&#10;&#10;    def find_entry(self, value):  # type: (Heap, Hashable) -&gt; Any&#10;        &quot;&quot;&quot; find entry by value &quot;&quot;&quot;&#10;        return self.entry_finder[value]&#10;&#10;    def peek(self):  # type: (Heap) -&gt; Any&#10;        &quot;&quot;&quot; peek first element &quot;&quot;&quot;&#10;        return self.heap[0]&#10;&#10;    def pop(self):  # type: (Heap) -&gt; Optional[Any]&#10;        &quot;&quot;&quot;Remove and return the lowest priority VALUE. Raise KeyError if empty.&quot;&quot;&quot;&#10;        while self.heap:&#10;            _, value = heapq.heappop(self.heap)&#10;            if value is not Heap.REMOVED:&#10;                del self.entry_finder[value]  # так как это операция pop то удалим также из словаря&#10;                return value&#10;        return None&#10;&#10;    def __repr__(self):&#10;        return f&quot;heap={self.heap} \n dict={self.entry_finder}&quot;" description="NEW  [class sorted by value]  {class hashed by key}" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="func find nearest clothest value" value="idx, val = min(enumerate(points), key=lambda idx_pt:abs(idx_pt[1][0] - to_point[0]))" description="в списке найти значение наиболее близкое к заданному" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="func  число разложить на цифры" value="n = 123&#10;while n &gt; 0:&#10;    n, digit = divmod(n, 10)&#10;    print(digit) # 3 2 1" description="n, digit = divmod(n, 10)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="formap MIN k min elements O(N log k)" value="# 2-3. build heap of top k frequent elements and&#10;# convert it into an output array&#10;# O(N log k) time&#10;counter = collections.Counter(nums)&#10;&#10;# для возвращения используются только ключи словаря&#10;# а для сортировки используем только значения словаря&#10;return heapq.nlargest(k, counter.keys(), key=counter.get)" description="heapq.nlargest" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TRIGGER SUPER" value="trigger = 1&#10;&#10;# flip the trigger&#10;trigger = 1 - trigger" description="trigger = 1 - trigger" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TRIGGER" value="trigger = False&#10;&#10;def run_once(proc):&#10;    nonlocal trigger&#10;    if trigger:&#10;        return&#10;    else:&#10;        trigger = True&#10;        proc()&#10;&#10;def is_only_one_zero(elem):&#10;    nonlocal trigger&#10;    if not trigger and elem == 0:&#10;        trigger = True&#10;        return True&#10;    else:&#10;        return False" description="run only once" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="formap MIN k min elements O(N)" value="def find_k_largest(self, nums: List[int], nth: int) -&gt; int:&#10;        length = len(nums)&#10;        if not nums:&#10;            return 0&#10;        if length &lt; 2:&#10;            return max(nums)&#10;&#10;        def swap(i, j):&#10;            nums[i], nums[j] = nums[j], nums[i]&#10;&#10;        # randomly find pivot&#10;        pivot_index = random.randint(0, length - 1)  # [1,10]&#10;        pivot = nums[pivot_index]&#10;        swap(0, pivot_index)&#10;        border = 1&#10;&#10;        # split above and below pivot&#10;        for j in range(1, length):&#10;            if nums[j] &lt; pivot:&#10;                swap(j, border)&#10;                border += 1&#10;&#10;        # put pivot back&#10;        swap(0, border-1) # важно обменятся с последним элементом их ЛЕВОЙ половины&#10;&#10;        if border == nth:&#10;            return pivot&#10;        if nth &lt; border:&#10;            return self.find_k_largest(nums[:border - 1], nth)&#10;        return self.find_k_largest(nums[border:], nth - border)  # idx больше на еденицу чем I тогда начнем искать с 0 те это след миним эллемент" description="hoara i-order statistic problem" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class LinkedList single 1" value="class Node(object):&#10;    &quot;&quot;&quot; node for single linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self, val):&#10;        self.val = val&#10;        self.next = None&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;&#10;class SingleLinkedList(object):&#10;    &quot;&quot;&quot; single linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        &quot;&quot;&quot; Initialize your data structure here.&quot;&quot;&quot;&#10;        self.head = Node(None)  # sentinel node&#10;        self.size = 0&#10;&#10;    def get(self, index: int) -&gt; int:&#10;        &quot;&quot;&quot; Get the value of the index-th node in the linked list.&#10;&#10;        If the index is invalid, return -1.&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return -1&#10;&#10;        node = self.head&#10;        for _ in range(index + 1):  # because +1 sentinel node&#10;            node = node.next&#10;&#10;        return node.val&#10;&#10;    def addAtHead(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the first element of the linked list.&#10;&#10;        After the insertion, the new node will be the first node of the linked list.&#10;        O(1)&quot;&quot;&quot;&#10;        self.addAtIndex(0, val)&#10;&#10;    def addAtTail(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Append a node of value val to the last element of the linked list.&#10;&#10;        O(N)&quot;&quot;&quot;&#10;        self.addAtIndex(self.size, val)&#10;&#10;    def addAtIndex(self, index: int, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list.&#10;&#10;        If index equals to the length of linked list, the node will be appended to the end of linked list.&#10;        If index is greater than the length, the node will not be inserted.&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt;= self.size:&#10;            return&#10;&#10;        node = self.head&#10;        for _ in range(index):  # get prev node, because +1 sentinel node&#10;            node = node.next&#10;&#10;        new_node = Node(val)&#10;        new_node.next = node.next&#10;        node.next = new_node&#10;&#10;        self.size += 1&#10;&#10;    def deleteAtIndex(self, index: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid.&#10;&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return&#10;&#10;        node = self.head&#10;        for _ in range(index):  # get prev node, because +1 sentinel node&#10;            node = node.next&#10;&#10;        node.next = node.next.next&#10;&#10;        self.size -= 1&#10;&#10;    def __repr__(self):&#10;        list_repr = []&#10;&#10;        node = self.head&#10;        for _ in range(self.size):  # because +1 sentinel node&#10;            node = node.next&#10;            list_repr += [node]&#10;&#10;        return str(list_repr)" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class LinkedList single 2" value="class ListNode(object):&#10;    &quot;&quot;&quot; node for single linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self, val):&#10;        self.val = val&#10;        self.next = None&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;&#10;class SingleLinkedList(object):&#10;    &quot;&quot;&quot; single linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        &quot;&quot;&quot; Initialize your data structure here.&quot;&quot;&quot;&#10;        self.head = ListNode(None)  # sentinel node&#10;        self.size = 0&#10;&#10;    def get(self, index: int) -&gt; int:&#10;        &quot;&quot;&quot; Get the value of the index-th node in the linked list.&#10;&#10;        If the index is invalid, return -1.&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return -1&#10;&#10;        node = self.head&#10;        for _ in range(index + 1):  # because + 0-th node&#10;            node = node.next&#10;&#10;        return node.val&#10;&#10;    def add_at_head(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the first element of the linked list.&#10;&#10;        After the insertion, the new node will be the first node of the linked list.&#10;        O(1)&quot;&quot;&quot;&#10;        self.add_at_index(0, val)&#10;&#10;    def add_at_tail(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Append a node of value val to the last element of the linked list.&#10;&#10;        O(N)&quot;&quot;&quot;&#10;        self.add_at_index(self.size, val)&#10;&#10;    def add_at_index(self, index: int, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list.&#10;&#10;        If index equals to the length of linked list, the node will be appended to the end of linked list.&#10;        If index is greater than the length, the node will not be inserted.&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt;= self.size:&#10;            return&#10;&#10;        node_prev = self.head&#10;        for _ in range(index):  # prev node, because without 0-th node&#10;            node_prev = node_prev.next&#10;        node_next = node_prev.next&#10;&#10;        node_prev.next = node_new = ListNode(val)&#10;        node_new.next = node_next&#10;&#10;        self.size += 1&#10;&#10;    def delete_at_index(self, index: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid.&#10;&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return&#10;&#10;        node_prev = self.head&#10;        for _ in range(index):  # prev node, because without 0-th node&#10;            node_prev = node_prev.next&#10;        node_next = node_prev.next.next&#10;&#10;        node_prev.next = node_next&#10;&#10;        self.size -= 1&#10;&#10;    def __repr__(self):&#10;        list_repr = []&#10;&#10;        node = self.head&#10;        for _ in range(self.size):  # because size is a count of elements&#10;            node = node.next&#10;            list_repr += [node]&#10;&#10;        return str(list_repr)&#10;&#10;&#10;N1, N2, N3, N4, N5 = ListNode(1), ListNode(2), ListNode(3), ListNode(4), ListNode(5)&#10;N1.next, N2.next, N3.next, N4.next = N2, N3, N4, N5&#10;L = SingleLinkedList()&#10;L.head.next = N1&#10;L.size=5&#10;print(L)" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class LinkedList double" value="class ListNode(object):&#10;    &quot;&quot;&quot; node for single linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self, val):&#10;        self.val = val&#10;        self.prev = None&#10;        self.next = None&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;&#10;class DoubleLinkedList(object):&#10;    &quot;&quot;&quot; double linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        &quot;&quot;&quot; Initialize your data structure here.&quot;&quot;&quot;&#10;        self.head = ListNode(&quot;HEAD&quot;)  # sentinel node&#10;        self.tail = ListNode(&quot;TAIL&quot;)&#10;&#10;        self.head.next = self.tail&#10;        self.tail.prev = self.head&#10;&#10;        self.size = 0&#10;&#10;    def get(self, index: int) -&gt; int:&#10;        &quot;&quot;&quot; Get the value of the index-th node in the linked list.&#10;&#10;        If the index is invalid, return -1.&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return -1&#10;&#10;        if index + 1 &lt; self.size - index:&#10;            node = self.head&#10;            for _ in range(index + 1):  # because + 0-th node&#10;                node = node.next&#10;        else:&#10;            node = self.tail&#10;            for _ in range(self.size - index):&#10;                node = node.prev&#10;&#10;        return node.val&#10;&#10;    def addAtHead(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the first element of the linked list.&#10;&#10;        After the insertion, the new node will be the first node of the linked list.&#10;        O(1)&quot;&quot;&quot;&#10;        self.addAtIndex(0, val)&#10;&#10;    def addAtTail(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Append a node of value val to the last element of the linked list.&#10;&#10;        O(1)&quot;&quot;&quot;&#10;        self.addAtIndex(self.size, val)&#10;&#10;    def addAtIndex(self, index: int, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list.&#10;&#10;        If index equals to the length of linked list, the node will be appended to the end of linked list.&#10;        If index is greater than the length, the node will not be inserted.&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt;= self.size:&#10;            return&#10;&#10;        if index + 1 &lt; self.size - index:&#10;            node_prev = self.head&#10;            for _ in range(index):  # get prev node, because without 0-th node&#10;                node_prev = node_prev.next&#10;            node_next = node_prev.next&#10;        else:&#10;            node_next = self.tail&#10;            for _ in range(self.size - index):  # get exactly node for insertion position (currently it is succ node)&#10;                node_next = node_next.prev&#10;            node_prev = node_next.prev&#10;&#10;        node_prev.next = node_next.prev = node_new = ListNode(val)&#10;        node_new.prev = node_prev&#10;        node_new.next = node_next&#10;&#10;        self.size += 1&#10;&#10;    def deleteAtIndex(self, index: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid.&#10;&#10;        O(N)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return&#10;&#10;        if index + 1 &lt; self.size - index:&#10;            node_prev = self.head&#10;            for _ in range(index):  # get prev node, because without 0-th node&#10;                node_prev = node_prev.next&#10;            node_next = node_prev.next.next  # eventualy it is succ node&#10;        else:&#10;            node_next = self.tail&#10;            for _ in range(self.size - index - 1):  # get exactly node for deleted position ( -1next  it is succ node)&#10;                node_next = node_next.prev&#10;            node_prev = node_next.prev.prev  # eventualy it is pred node&#10;&#10;        node_prev.next = node_next&#10;        node_next.prev = node_prev&#10;&#10;        self.size -= 1&#10;&#10;    def __repr__(self):&#10;        list_repr = []&#10;&#10;        node = self.head&#10;        for _ in range(self.size):  # because size is a count of elements&#10;            node = node.next&#10;            list_repr += [node]&#10;&#10;        return str(list_repr)&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new CACHE  LRU Least recently used FIXEDSIZE v2 SUPER" value="class LRU(collections.OrderedDict):&#10;    &quot;&quot;&quot; Limit size, evicting the least recently looked-up key when full &quot;&quot;&quot;&#10;&#10;    def __init__(self, maxsize=128, /, *args, **kwds):&#10;        self.maxsize = maxsize&#10;        super().__init__(*args, **kwds)&#10;&#10;    def __getitem__(self, key):&#10;        value = super().__getitem__(key)&#10;        self.move_to_end(key)&#10;        return value&#10;&#10;    def __setitem__(self, key, value):&#10;        super().__setitem__(key, value)&#10;        self.move_to_end(key)&#10;        if len(self) &gt; self.maxsize:&#10;            self.popitem(last=False)&#10;&#10; " description="OrderedDict  размер кэша можно ограничить" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="map new DoubleLinkedListAndDict" value="class Node(object):&#10;    &quot;&quot;&quot; node for single linked list&quot;&quot;&quot;&#10;&#10;    def __init__(self, val):&#10;        self.val = val&#10;        self.prev = None&#10;        self.next = None&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;class DoubleLinkedListAndDict(object):&#10;    &quot;&quot;&quot; list works with node itself, not its vals. Most operations O(1). Ordered or sorted list also.&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        &quot;&quot;&quot; Initialize your data structure here.&quot;&quot;&quot;&#10;        self.head = Node(&quot;HEAD&quot;)  # sentinel node&#10;        self.tail = Node(&quot;TAIL&quot;)&#10;&#10;        self.head.next = self.tail&#10;        self.tail.prev = self.head&#10;&#10;        self.size = 0&#10;&#10;        self.cache = {}&#10;        self.cache[-1] = self.head&#10;&#10;    def get(self, index: int) -&gt; Node:&#10;        &quot;&quot;&quot; Get the value of the index-th node in the linked list.&#10;&#10;        If the index is invalid, return -1.&#10;        O(1)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return -1&#10;&#10;        return self.cache.get(index, -1)&#10;&#10;    def _get(self, index: int) -&gt; Node:&#10;        # please notice, no check input args !&#10;        node = self.cache.get(index, -1)&#10;        return node, node.next&#10;&#10;    def addAtHead(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the first element of the linked list.&#10;&#10;        After the insertion, the new node will be the first node of the linked list.&#10;        O(1)&quot;&quot;&quot;&#10;        self.addAtIndex(0, val)&#10;&#10;    def addAtTail(self, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Append a node of value val to the last element of the linked list.&#10;&#10;        O(1)&quot;&quot;&quot;&#10;        self.addAtIndex(self.size, val)&#10;&#10;    def addAtIndex(self, index: int, val: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list.&#10;&#10;        If index equals to the length of linked list, the node will be appended to the end of linked list.&#10;        If index is greater than the length, the node will not be inserted.&#10;        O(1)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt;= self.size:&#10;            return&#10;&#10;        node_prev, node_next = self._get(index - 1)&#10;&#10;        node_prev.next = node_next.prev = node_new = Node(val)&#10;        node_new.prev = node_prev&#10;        node_new.next = node_next&#10;&#10;        self.size += 1&#10;        self.cache[index] = node_new&#10;&#10;    def deleteAtIndex(self, index: int) -&gt; None:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid.&#10;&#10;        O(1)&quot;&quot;&quot;&#10;        if not 0 &lt;= index &lt; self.size:&#10;            return&#10;&#10;        node_prev, node_next = self._get(index - 1)&#10;&#10;        node_prev.next = node_next&#10;        node_next.prev = node_prev&#10;&#10;        self.size -= 1&#10;        del self.cache[index]&#10;&#10;    def __repr__(self):&#10;        list_repr = []&#10;&#10;        node = self.head&#10;        for _ in range(self.size):  # because size is a count of elements&#10;            node = node.next&#10;            list_repr += [node]&#10;&#10;        return str(list_repr)&#10;" description="operations O(1). Ordered or sorted list also." toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function CYCLE FIND v1" value="# множество можно использовать для обнаружения циклов уже виденных элементов&#10;seen=set()&#10;while node:&#10;    if node in seen:&#10;        return True # found cycle!&#10;    else:&#10;        seen|= {node}&#10;    node= node.next" description="множество можно использовать для обнаружения циклов уже виденных элементов" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TEMPLATE  two_pointers for linked list" value="# Initialize slow &amp; fast pointers&#10;node_slow = head&#10;node_fast = head&#10;# Change this condition to fit specific problem.&#10;# Attention: remember to avoid null-pointer error&#10;while node_slow and node_fast and node_fast.next:&#10;    node_slow = node_slow.next  # move slow pointer one step each time&#10;    node_fast = node_fast.next.next  # move fast pointer two steps each time&#10;    if node_slow == node_fast:  # change this condition to fit specific problem&#10;        return True&#10;&#10;return False  # change return value to fit specific problem" description="from LEETCODE" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="listlinked _insert_node" value="def _insert_node(self, prev, curr, next):&#10;    prev.next = curr&#10;    curr.next = next" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function CYCLE FIND v2" value="# множество можно использовать для обнаружения циклов уже виденных элементов&#10;node, seen = llist, set()&#10;while node and node not in seen:&#10;    # main work   &#10;      &#10;    seen|= {node}&#10;    node= node.next&#10;" description="множество можно использовать для обнаружения циклов уже виденных элементов" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class binary tree" value="class TreeNode(object):&#10;    &quot;&quot;&quot; binary tree node&quot;&quot;&quot;&#10;&#10;    def __init__(self, x):&#10;        self.val = x&#10;        self.left = None&#10;        self.right = None&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;&#10;&#10;class BinaryTree(object):&#10;    &quot;&quot;&quot; ok &quot;&quot;&quot;&#10;&#10;    # &lt;editor-fold desc=&quot;pre order&quot;&gt;&#10;    def preorder_traversal_recursive_bottomup(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree pre-order traversal recursive(bottom-up)&quot;&quot;&quot;&#10;        if not root:&#10;            return []&#10;&#10;        tree_left = self.preorder_traversal_recursive_bottomup(root.left)&#10;        tree_right = self.preorder_traversal_recursive_bottomup(root.right)&#10;        return [root.val] + tree_left + tree_right&#10;&#10;    def preorder_traversal_recursive_topdown(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)ST tree pre-order traversal recursive(top-down)&quot;&quot;&quot;&#10;        traverse = []&#10;&#10;        def helper(node):&#10;            nonlocal traverse&#10;            if not node:&#10;                return&#10;&#10;            traverse += [node.val]&#10;            helper(node.left)&#10;            helper(node.right)&#10;&#10;        helper(root)&#10;        return traverse&#10;&#10;    def preorder_traversal_iterative(self, root: TreeNode) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree pre-order traversal &quot;&quot;&quot;&#10;        stack = [root]&#10;        while node := stack.pop() if stack else None:&#10;            yield node.val  # main work&#10;&#10;            if node.right:&#10;                stack += [node.right]&#10;            if node.left:&#10;                stack += [node.left]  # would be on top of stack, left node processed first&#10;&#10;    def preorder_traversal_iterative2(self, root: TreeNode) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree pre-order traversal &quot;&quot;&quot;&#10;        stack = [root]&#10;        while stack:&#10;            node = stack.pop()&#10;            if node is None:&#10;                continue&#10;            yield node.val  # main work&#10;&#10;            stack += [node.right]&#10;            stack += [node.left]  # would be on top of stack, left node processed first&#10;&#10;    def preorder_traversal_iterative_variant(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)ST tree pre-order traversal &quot;&quot;&quot;&#10;        result = []&#10;&#10;        stack = [root]&#10;        while node := stack.pop() if stack else None:&#10;            result += [node.val]  # main work&#10;&#10;            if node.right:&#10;                stack += [node.right]&#10;            if node.left:&#10;                stack += [node.left]  # would be on top of stack, left node processed first&#10;&#10;        return result&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;in order&quot;&gt;&#10;    def inorder_traversal_recursive_bottomup(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree in-order traversal recursive(bottom-up)&quot;&quot;&quot;&#10;        if not root:&#10;            return []&#10;&#10;        tree_left = self.inorder_traversal_recursive_bottomup(root.left)&#10;        tree_right = self.inorder_traversal_recursive_bottomup(root.right)&#10;        return tree_left + [root.val] + tree_right&#10;&#10;    def inorder_traversal_recursive_topdown(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)ST tree in-order traversal recursive(top-down)&quot;&quot;&quot;&#10;        traverse = []&#10;&#10;        def helper(node):&#10;            nonlocal traverse&#10;            if not node:&#10;                return&#10;&#10;            helper(node.left)&#10;            traverse += [node.val]&#10;            helper(node.right)&#10;&#10;        helper(root)&#10;&#10;        return traverse&#10;&#10;    # def inorder_traversal_iterative(self, root: TreeNode) -&gt; Generator[int]:  # type: Type[TreeNode]&#10;    def inorder_traversal_iterative(self, root: TreeNode) -&gt; Generator[int, Any, None]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree in-order traversal&#10;&#10;        - сначала в стек разворачиваем левую ветвь&#10;&#9;    - затем достаем из стека = это и будет элемент&#10;        а после посещения вершины нужно перенаправить на правую ветвь&#10;        &quot;&quot;&quot;&#10;        stack, node = [], root&#10;        while stack or node:&#10;            while node:&#10;                stack += [node]&#10;                node = node.left&#10;            node = stack.pop()&#10;            yield node.val  # main work&#10;            node = node.right&#10;&#10;    def inorder_traversal_iterative_variant(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)ST tree in-order traversal &quot;&quot;&quot;&#10;        result = []&#10;&#10;        stack, node = [], root&#10;        while stack or node:&#10;            while node:&#10;                stack += [node]&#10;                node = node.left&#10;            node = stack.pop()&#10;            result += [node.val]  # main work&#10;            node = node.right&#10;&#10;        return result&#10;&#10;    def inorder_traversal_moris(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)T O(1)S tree in-order traversal &quot;&quot;&quot;&#10;        node = root&#10;        while node:&#10;            if not node.left:  # если слева нет ноды то выводим текущую в результат и делаем текущей правую ноду&#10;                yield node.val&#10;                node = node.right&#10;            else:  # если слева есть нода, то зацикливаем.. и делаем ее текущей&#10;                node_next_curr = node.left&#10;&#10;                # find last&#10;                node_right_branch = node.left&#10;                while node_right_branch:&#10;                    node_right_branch_end = node_right_branch&#10;                    node_right_branch = node_right_branch.right&#10;&#10;                # create cycle&#10;                node_right_branch_end.right = node&#10;                node.left = None  # TODO(wilmer.krisp@yahoo.com) breaks source tree&#10;&#10;                node = node_next_curr&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;post order&quot;&gt;&#10;    def postorder_traversal_recursive_bottomup(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree post-order traversal recursive(bottom-up)&quot;&quot;&quot;&#10;        if not root:&#10;            return []&#10;&#10;        tree_left = self.postorder_traversal_recursive_bottomup(root.left)&#10;        tree_right = self.postorder_traversal_recursive_bottomup(root.right)&#10;        return tree_left + tree_right + [root.val]&#10;&#10;    def postorder_traversal_recursive_topdown(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot; O(N)ST tree post-order traversal recursive(top-down)&quot;&quot;&quot;&#10;        traverse = []&#10;&#10;        def helper(node):&#10;            nonlocal traverse&#10;            if not node:&#10;                return&#10;&#10;            helper(node.left)&#10;            helper(node.right)&#10;            traverse += [node.val]&#10;&#10;        helper(root)&#10;&#10;        return traverse&#10;&#10;    def postorder_traversal_iterative(self, root: TreeNode) -&gt; List[int]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree post-order traversal &quot;&quot;&quot;&#10;&#10;        return list(self.preorder_traversal_iterative(root))[::-1]&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;level order&quot;&gt;&#10;    def levelorder_traversal_iterative(self, root: TreeNode):&#10;        &quot;&quot;&quot;SUPER BFS O(N)ST tree level-order traversal &quot;&quot;&quot;&#10;        queue = collections.deque([root])&#10;        while node := queue.pop() if queue else None:&#10;            yield node.val  # main work&#10;&#10;            if node.left:&#10;                queue.appendleft(node.left)&#10;            if node.right:&#10;                queue.appendleft(node.right)&#10;&#10;    def levelorder_traversal_recursive_topdown(self, root: TreeNode) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree level-order traversal recursive(top-down)&quot;&quot;&quot;&#10;        levels = collections.defaultdict(list)&#10;        if not root:&#10;            return levels.values()&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return&#10;            levels[level] += [node.val]&#10;            helper(node.left, level + 1)&#10;            helper(node.right, level + 1)&#10;&#10;        helper(root, 0)&#10;&#10;        return itertools.chain.from_iterable(levels.values())&#10;&#10;    def levelorder_traversal_recursive_bottomup(self, root: TreeNode) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot; O(N)ST tree level-order traversal recursive(bottom up)&quot;&quot;&quot;&#10;        if not root:&#10;            return []&#10;&#10;        def group_dicts(*dicts):&#10;            &quot;&quot;&quot; group_dicts(map1, map2, map3)&quot;&quot;&quot;&#10;            items = [d.items() for d in dicts]&#10;            merged = collections.defaultdict(list)&#10;            for key, value in itertools.chain.from_iterable(items):&#10;                merged[key] += value&#10;            return merged&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return {}&#10;&#10;            level_node = {&#10;                level: [node.val]&#10;            }&#10;            level_left = helper(node.left, level + 1)&#10;            level_right = helper(node.right, level + 1)&#10;            return group_dicts(level_left, level_right, level_node)&#10;&#10;        levels = helper(root, 0).items()&#10;        levels_sorted = sorted(levels)&#10;        levels_vals = [value for key, value in levels_sorted]&#10;        return itertools.chain.from_iterable(levels_vals)&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;level order with levelNum&quot;&gt;&#10;    def levelorder_traversal_recursive_withlevelnum(self, root: TreeNode) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree level-order traversal &quot;&quot;&quot;&#10;        levels = collections.defaultdict(list)&#10;        if not root:&#10;            return levels.values()&#10;&#10;        def helper(node, level):&#10;            if not node:&#10;                return&#10;            levels[level] += [node.val]&#10;            helper(node.left, level + 1)&#10;            helper(node.right, level + 1)&#10;&#10;        helper(root, 0)&#10;&#10;        return levels.values()&#10;&#10;    def levelorder_traversal_iterative_withlevelnum_var1(self, root: TreeNode) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot;SUPER O(N)ST tree level-order traversal&#10;&#10;        суперподход: запихнуть вместе с нодой в стек дополнительную информацию&#10;        те в стеке кортеж (нода, значение)&#10;&#10;        stack based&#10;        &quot;&quot;&quot;&#10;        levels = collections.defaultdict(list)&#10;&#10;        stack = [(1, root)]&#10;        while stack:&#10;            level, node = stack.pop()&#10;            levels[level] += [node.val]&#10;&#10;            if node.left:&#10;                stack += [(level + 1, node.left)]&#10;            if node.right:&#10;                stack += [(level + 1, node.right)]&#10;&#10;        return levels.values()&#10;&#10;    def levelorder_traversal_iterative_withlevelnum_var1b(self, root: TreeNode) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot; O(N)ST tree level-order traversal&#10;&#10;        queue based&#10;        &quot;&quot;&quot;&#10;        levels = collections.defaultdict(list)&#10;&#10;        queue = collections.deque([(1, root)])&#10;        while queue:&#10;            level, node = queue.pop()&#10;            levels[level] += [node.val]&#10;&#10;            if node.left:&#10;                queue.appendleft((level + 1, node.left))&#10;            if node.right:&#10;                queue.appendleft((level + 1, node.right))&#10;&#10;        return levels.values()&#10;&#10;    def levelorder_traversal_iterative_withlevelnum_var2(self, root: TreeNode) -&gt; List[List[int]]:&#10;        &quot;&quot;&quot; O(N)ST tree level-order traversal&#10;&#10;        принцип комплиментарности&#10;&#9;    - выберем справа все ноды данного уровня , все равно добавлять ноды будем с другого конца,&#10;&#9;    поэтому они не смешаются (и я случайно не выберу только что добавленную ноду)&#10;        после добавления всех нод (и удаления всех нод текущего уровня) = это и есть ноды следующего уровня&#10;        &quot;&quot;&quot;&#10;        levels, level = collections.defaultdict(list), -1&#10;&#10;        queue = collections.deque([root])&#10;        while queue:&#10;            level_len, level = len(queue), level + 1&#10;&#10;            for _ in range(level_len):  # все равно добавлять ноды будем с другого конца, поэтому они не смешаются&#10;                node = queue.pop()&#10;                levels[level] += [node.val]&#10;&#10;                if node.left:&#10;                    queue.appendleft(node.left)&#10;                if node.right:&#10;                    queue.appendleft(node.right)&#10;&#10;        return levels.values()&#10;&#10;    # &lt;/editor-fold&gt;&#10;    # &lt;editor-fold desc=&quot;various methods&quot;&gt;&#10;    def compare_trees_recursive(self, root1, root2):&#10;        &quot;&quot;&quot; compare two trees recursive&quot;&quot;&quot;&#10;        if not root1 and not root2:&#10;            return True&#10;        if not root1 or not root2:&#10;            return False&#10;        return root1.val == root2.val and self.compare_trees_recursive(root1.left, root2.left) and self.compare_trees_recursive(root1.right, root2.right)&#10;&#10;    def compare_trees_iterative(self, root1, root2):&#10;        &quot;&quot;&quot;SUPER compare two trees iterative&#10;        &#10;        в стек записали кортеж из двух нод внутри&#10;        &quot;&quot;&quot;&#10;        stack = [(root1, root2)]&#10;        while stack:&#10;            node1, node2 = stack.pop()&#10;            if not node1 and not node2:  # тк список может хранить None значения&#10;                continue&#10;            if not node1 or not node2:&#10;                return False&#10;            if node1.val != node2.val:&#10;                return False&#10;            stack += [(node1.right, node2.right), (node1.left, node2.left)]&#10;        return True&#10;&#10;    def compare_trees_iterative_variant(self, root1, root2):&#10;        &quot;&quot;&quot; compare two trees iterative&quot;&quot;&quot;&#10;        stack = [root2, root1]&#10;        while stack:&#10;            node1, node2 = stack.pop(), stack.pop() if stack else None&#10;            if not node1 and not node2:  # тк список может хранить None значения&#10;                continue&#10;            if not node1 or not node2:&#10;                return False&#10;            if node1.val != node2.val:&#10;                return False&#10;            stack += [node2.right, node1.right, node2.left, node1.left]&#10;        return True&#10;&#10;    def serialize_recursive(self, root):&#10;        &quot;&quot;&quot; pre-order recursive(bottom-up) traversal &quot;&quot;&quot;&#10;        if not root:&#10;            return 'None'&#10;&#10;        tree_left = self.serialize_recursive(root.left)&#10;        tree_right = self.serialize_recursive(root.right)&#10;        return str(root.val) + ',' + tree_left + ',' + tree_right&#10;&#10;    def serialize_iterative(self, root):&#10;        &quot;&quot;&quot; pre-order iterative traversal &quot;&quot;&quot;&#10;        tree_list = []&#10;&#10;        stack = [root]&#10;        while stack:&#10;            node = stack.pop()&#10;            tree_list += [str(node.val) if node else 'None']  # main work&#10;            if node is None:&#10;                continue&#10;&#10;            stack += [node.right, node.left]  # would be on top of stack, left node processed first&#10;&#10;        return &quot;,&quot;.join(tree_list)&#10;&#10;    def deserialize_recursive(self, data):&#10;        &quot;&quot;&quot; pre-order recursive(bottom-up) traversal &quot;&quot;&quot;&#10;        tree_list = data.split(',')&#10;&#10;        def traversal():&#10;            node_next = tree_list.pop(0)&#10;            if node_next == 'None':&#10;                return None&#10;&#10;            node_new = TreeNode(int(node_next))&#10;            node_new.left = traversal()&#10;            node_new.right = traversal()&#10;            return node_new&#10;&#10;        return traversal()&#10;&#10;    def deserialize_iterative(self, data):&#10;        &quot;&quot;&quot; pre-order iterative traversal &quot;&quot;&quot;&#10;        tree_list = data.split(',')&#10;        tree_list.reverse()&#10;&#10;        node_sentinel = TreeNode(0)&#10;        stack = [functools.partial(node_sentinel.__setattr__, &quot;left&quot;)]&#10;        while stack and tree_list:&#10;            command = stack.pop()&#10;            val = tree_list.pop()&#10;&#10;            if val == 'None':&#10;                command(None)&#10;                continue&#10;&#10;            node_new = TreeNode(val)  # main work&#10;            command(node_new)&#10;            stack += [functools.partial(node_new.__setattr__, &quot;right&quot;), functools.partial(node_new.__setattr__, &quot;left&quot;)]&#10;&#10;        return node_sentinel.left&#10;&#10;    print(&quot;&quot;)  # &lt;/editor-fold&gt;&#10;&#10;&#10;T1, T2, T3, T4, T5 = TreeNode(1), TreeNode(2), TreeNode(3), TreeNode(4), TreeNode(5)&#10;T1.left, T1.right = T2, T3&#10;T2.left, T2.right = T4, T5&#10;wilmerlibrary.draw_binary_tree(T1)" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal recursive preorder binary tree" value="def traversal( node_root):&#10;    if not node_root:&#10;        return []&#10;&#10;    tree_left = traversal(node_root.left)&#10;    tree_right = traversal(node_root.right)&#10;    return [node_root.val] + tree_left + tree_right" description="SUPER O(N)ST tree pre-order traversal recursive(bottom-up)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal iterative preorder binary tree (STACK BASED DFS)" value="def traversal(node_root):&#10;    stack = [node_root]&#10;    while node := stack.pop() if stack else None:&#10;        yield node.val  # main work&#10;&#10;        if node.right:&#10;            stack += [node.right]&#10;        if node.left:&#10;            stack += [node.left]  # would be on top of stack, left node processed first" description="SUPER O(N)ST tree pre-order traversal" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal iterative levelorder binary tree (QUEUE BASED BFS)" value="def traversal(node_root):&#10;    queue = collections.deque([node_root])&#10;    while node := queue.pop() if queue else None:&#10;        yield node.val  # main work&#10;&#10;        if node.left:&#10;            queue.appendleft(node.left)&#10;        if node.right:&#10;            queue.appendleft(node.right)" description="SUPER BFS O(N)ST tree level-order traversal" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal recursive levelorder binary tree (GROUPED LEVELS)" value="def traversal( node_root ) :&#10;    levels = collections.defaultdict(list)&#10;    if not node_root:&#10;        return levels.values()&#10;&#10;    def helper(node, level):&#10;        if not node:&#10;            return&#10;        levels[level] += [node.val]&#10;        helper(node.left, level + 1)&#10;        helper(node.right, level + 1)&#10;&#10;    helper(node_root, 0)&#10;&#10;    return itertools.chain.from_iterable(levels.values()) # levels.values() если нужно получить просто группы" description="SUPER O(N)ST tree level-order traversal recursive(top-down)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal iterative levelorder binary tree (ADDITIONAL INFO IN STACK)" value="def traversal(node_root )  :&#10;    levels = collections.defaultdict(list)&#10;&#10;    stack = [(1, node_root)]&#10;    while stack:&#10;        level, node = stack.pop()&#10;        levels[level] += [node.val]&#10;&#10;        if node.left:&#10;            stack += [(level + 1, node.left)]&#10;        if node.right:&#10;            stack += [(level + 1, node.right)]&#10;&#10;    return levels.values()" description="SUPER O(N)ST tree level-order traversal" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal compare tree" value="def compare_trees_recursive(root1, root2):&#10;    &quot;&quot;&quot; compare two trees recursive&quot;&quot;&quot;&#10;    if not root1 and not root2:&#10;        return True&#10;    if not root1 or not root2:&#10;        return False&#10;    return root1.val == root2.val and self.compare_trees_recursive(root1.left, root2.left) and self.compare_trees_recursive(root1.right, root2.right)&#10;&#10;def compare_trees_iterative(root1, root2):&#10;    &quot;&quot;&quot; compare two trees iterative&quot;&quot;&quot;&#10;    stack = [root2, root1]&#10;    while stack:&#10;        node1, node2 = stack.pop(), stack.pop() if stack else None&#10;        if not node1 and not node2: # тк список может хранить None значения&#10;            continue&#10;        if not node1 or not node2:&#10;            return False&#10;        if node1.val != node2.val:&#10;            return False&#10;        stack += [node2.right, node1.right, node2.left, node1.left]&#10;    return True" description="recursive and iterative" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function traversal iterative preorder binary tree (STACK BASED DFS + None elements)" value="def traversal(node_root):            &#10;    stack = [node_root]&#10;    while stack:&#10;        node = stack.pop()&#10;        yield node.val  # main work&#10;        if node is None: # стэк может содержать пустые элементы&#10;            continue&#10;&#10;        stack += [node.right, node.left]  # left would be on top of stack, left node processed first" description="SUPER O(N)ST tree pre-order traversal" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="class binary search tree BST" value="class TreeNode(object):&#10;    &quot;&quot;&quot; binary tree node&quot;&quot;&quot;&#10;&#10;    def __init__(self, x):&#10;        self.val = x&#10;        self.left = None&#10;        self.right = None&#10;&#10;    def __repr__(self):&#10;        return str(self.val)&#10;&#10;class BinarySearchTree(object):&#10;    &quot;&quot;&quot; BST&#10;    &#10;    inorder traversal выводит BST в порядке возрастания&#10;    &quot;&quot;&quot;&#10;&#10;    def is_valid_binary_search_tree(self, root: TreeNode) -&gt; bool:  # pylint: disable=invalid-name&#10;        &quot;&quot;&quot; ok &quot;&quot;&quot;&#10;&#10;        def helper(node, min_edge, max_edge):&#10;            if node is None:&#10;                return True&#10;&#10;            if not (min_edge &lt; node.val &lt; max_edge):&#10;                return False&#10;&#10;            if (node.left and node.val &lt;= node.left.val) or (node.right and node.val &gt;= node.right.val):&#10;                return False&#10;&#10;            return helper(node.left, min_edge, node.val) and helper(node.right, node.val, max_edge)&#10;&#10;        return helper(root, -math.inf, math.inf)&#10;&#10;    def search_iterative(self, root: TreeNode, val: int) -&gt; TreeNode:&#10;        &quot;&quot;&quot; O(height of tree)T O(1)S iterative tree traversal &quot;&quot;&quot;&#10;        node = root&#10;        while node:&#10;            if node.val == val:&#10;                return node&#10;            node = node.right if val &gt; node.val else node.left&#10;        return None&#10;&#10;    def search_recursive(self, root: TreeNode, val: int) -&gt; TreeNode:&#10;        &quot;&quot;&quot; O(height of tree)T O(height of tree)S recursive tree traversal &quot;&quot;&quot;&#10;        if root is None or val == root.val:&#10;            return root&#10;&#10;        return self.search_recursive(root.right, val) if val &gt; root.val else self.search_recursive(root.left, val)&#10;&#10;&#10;&#10;T1, T2, T3, T4, T5 = TreeNode(4), TreeNode(2), TreeNode(7), TreeNode(1), TreeNode(3)&#10;T1.left, T1.right = T2, T3&#10;T2.left, T2.right = T4, T5&#10;wilmerlibrary.draw_binary_tree(T1)" description="Bimary Search Tree = binary tree" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TEMPLATE devide and conquer" value="def divide_and_conquer( S ):&#10;    # (1). Divide the problem into a set of subproblems.&#10;    [S1, S2, ... Sn] = divide(S)&#10;&#10;    # (2). Solve the subproblem recursively,&#10;    #   obtain the results of subproblems as [R1, R2... Rn].&#10;    rets = [divide_and_conquer(Si) for Si in [S1, S2, ... Sn]]&#10;    [R1, R2,... Rn] = rets&#10;&#10;    # (3). combine the results from the subproblems.&#10;    #   and return the combined result.&#10;    return combine([R1, R2,... Rn])" description="from LEETCODE" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TEMPLATE backtracking" value="def backtrack(candidate):&#10;    if find_solution(candidate):&#10;        output(candidate)&#10;        return&#10;    &#10;    # iterate all possible candidates.&#10;    for next_candidate in list_of_candidates:&#10;        if is_valid(next_candidate):&#10;            # try this partial candidate solution&#10;            place(next_candidate)&#10;            # given the candidate, explore further.&#10;            backtrack(next_candidate)&#10;            # backtrack&#10;            remove(next_candidate)" description="from LEETCODE" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TEMPLATE backtracking My" value="class Solution(object):&#10;    &quot;&quot;&quot;ok &quot;&quot;&quot;&#10;&#10;    def solve(self, data):&#10;        &quot;&quot;&quot; ok &quot;&quot;&quot;&#10;        busy_data = [False] * 10&#10;&#10;        solution_set = set()&#10;        solution_result = []&#10;&#10;        def is_found_solution(y):&#10;            &quot;&quot;&quot; в каждом вызове рекурсии  это шаг к окончательному решению, поэтому следует проверять получилось ли решение  &quot;&quot;&quot;&#10;            return True&#10;&#10;        def add_solution():&#10;            nonlocal solution_result&#10;&#10;            solution = solution_set&#10;            solution_result += [solution]&#10;&#10;        def is_valid(x, y):&#10;            &quot;&quot;&quot; prune - если шаг(те текущая рекурсия) не ведет к решению то по ней и не идем &quot;&quot;&quot;&#10;            if busy_data:&#10;                return False&#10;            return True&#10;&#10;        def place(x, y):&#10;            &quot;&quot;&quot;добавить узел в ветвь текущего варианта&quot;&quot;&quot;&#10;            nonlocal solution_set&#10;            solution_set |= {(x,y)}&#10;            busy_data[x] = True&#10;&#10;        def remove(x, y):&#10;            &quot;&quot;&quot; backtrack - удалить узел в ветви текущего варианта&#10;            &#10;            в конце рекурсивного шага мы должны откатиться на предыдущую ветвь &#10;            (например удалить текущую ветвь решения, если она отслеживается) &quot;&quot;&quot;&#10;            nonlocal solution_set&#10;            solution_set -= {(x, y)}&#10;            busy_data[x] = False&#10;&#10;        def backtrack(y):&#10;            &quot;&quot;&quot; внутри рекурсии мы итерируемся по всем кандидатам решения, например по всем листьям корневого узла &quot;&quot;&quot; &#10;            for x in range(n):&#10;            &#10;                if not is_valid(x, y):&#10;                    continue&#10;                place(x, y)&#10;               &#10;                if is_found_solution(y): &#10;                    add_solution()&#10;                else:&#10;                    backtrack(y + 1)&#10;                    &#10;                remove(x, y)&#10;&#10;        backtrack(0)&#10;        return solution_result" description="from My" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
</templateSet>