<templateSet group="_ALGO">
  <template name="for WHILE  POP (GOOD dict iterate and delete element)" value="while $d0$:&#10;    print ($d0$.popitem())&#10;$END$    " description="while POPitem" toReformat="false" toShortenFQNames="true">
    <variable name="d0" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for WHILE POP + result" value="result  = []&#10;while $left$ :&#10;    fst=$left$[0]&#10;    lst=$left$[-1]&#10;    result[:0] = [$left$.pop()]  &#10;&#10;$END$    " description="while POPitem" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for WHILE POPLEFT + result" value="result  = []&#10;arr=deque($left$)&#10;while  :&#10;    fst=arr[0]&#10;    lst=arr[-1]&#10;    result+= [arr.popleft()]  &#10;&#10;$END$&#10;  " description="while POPLEFTitem" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="func readfile" value="def file_to_array(filename):&#10;    result = []&#10;    for line in open(filename):&#10;        str=line.strip()&#10;        if not str:&#10;            continue&#10;        num=int(str)&#10;        assert isinstance(num,int), f&quot;NUM={num}&quot;&#10;        result.append(num)&#10;    print(&quot;Integers readed:&quot;,len(result) )&#10;    return result&#10;&#10;&#10;ARR4 = file_to_array(r'C:\Users\trans\Downloads\IntegerArray.txt')&#10;print(&quot;ARR4&gt;&gt;&quot;,ARR4[:3])&#10;&#10;&#10;&#10;&#10;***&#10;def file_to_array(filename):&#10;    result = []&#10;    for line in open(filename):&#10;        result.append(line.strip())&#10;    return result&#10;&#10;&#10;ARR4 = file_to_array(r'C:\Users\trans\Downloads\IntegerArray.txt')&#10;***" description="for line in open(filename)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graphic functions DRAW" value="import matplotlib.pyplot as plt&#10;from math import *&#10;&#10;F1 = [x ** 0.5 for x in range(1, 100)]&#10;F2 = [2 ** (log(x)) for x in range(1, 100)]&#10;F3 = [x ** (5/3) for x in range(1, 100)]&#10;&#10;fig, ax = plt.subplots()&#10;ax.plot(F1,color='black')&#10;ax.plot(F2,color='red')&#10;ax.plot(F3)&#10;plt.show()" description="matplotlib" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for FOR LIST" value="for i in range(0,len($P$)):&#10;    print($P$[i])" description="for i in range(len)" toReformat="false" toShortenFQNames="true">
    <variable name="P" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graph  undirected DRAW" value="import networkx as nx&#10;import matplotlib.pyplot as plt&#10;&#10;def draw_graph():&#10;    G = nx.Graph()&#10;    G.add_node(&quot;A&quot;)&#10;    G.add_node(&quot;B&quot;)&#10;    G.add_node(&quot;C&quot;)&#10;    G.add_node(&quot;D&quot;)&#10;    G.add_node(&quot;E&quot;)&#10;    G.add_node(&quot;F&quot;)&#10;    G.add_node(&quot;G&quot;)&#10;    G.add_edge(&quot;A&quot;, &quot;B&quot;)&#10;    G.add_edge(&quot;B&quot;, &quot;C&quot;)&#10;    G.add_edge(&quot;C&quot;, &quot;E&quot;)&#10;    G.add_edge(&quot;C&quot;, &quot;F&quot;)&#10;    G.add_edge(&quot;D&quot;, &quot;E&quot;)&#10;    G.add_edge(&quot;F&quot;, &quot;G&quot;)&#10;    plt.figure(figsize=(8, 8))&#10;    nx.draw(G)&#10;&#10;draw_graph()" description="networkx" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER BFS" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph):&#10;    &quot;&quot;&quot; $bfs$ &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;    &#10;    q, processed, start_vertex = [], set(), next(iter(graph))&#10;    &#10;    def process(vertex):&#10;        nonlocal q, processed&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        q[:0] = [vertex]&#10;        return True&#10;    &#10;    print(&quot;start verticle not processed=&quot;, start_vertex)&#10;    process(start_vertex)&#10;    while q:&#10;        v = q.pop()&#10;        for e in graph[v]:&#10;              if process(e):&#10;                print(f&quot;process e={e}&quot;)&#10;                #print(f&quot;   v={v} e={e} arr={q}&quot;)&#10;&#10;    return {}&#10;&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_,result)&#10;&#10;&#10;main_$bfs$()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graph  undirected DRAW with labels" value="import networkx as nx&#10;import matplotlib.pyplot as plt&#10;&#10;&#10;def draw_graph(graph,labels_ =None):&#10;    &quot;&quot;&quot;graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&quot;&quot;&quot;&#10;    if not labels_: labels_ = {}&#10;&#10;    g = nx.DiGraph()&#10;&#10;    for v in graph:&#10;        g.add_node(v)&#10;        label_additional=labels_.get(v, &quot;&quot;);&#10;        labels_[v]= f&quot;{v}  ={label_additional}&quot;&#10;        for e in graph[v]:&#10;            g.add_edge(v, e)&#10;&#10;    pos = nx.spring_layout(g)&#10;    nx.draw_networkx_nodes(g, pos)&#10;&#10;&#10;    nx.draw_networkx_labels(g, pos,labels=labels_)&#10;    # nx.draw_networkx_edge_labels(g, pos)&#10;    nx.draw_networkx_edges(g, pos, edge_color='r', arrows=True)&#10;    plt.show()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER DFS" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph):&#10;    &quot;&quot;&quot; $bfs$ &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    q, processed, start_vertex = [], set(), next(iter(graph))&#10;&#10;    def is_process(vertex):&#10;        nonlocal q, processed&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        return True&#10;&#10;    def will_process(vertex):&#10;        nonlocal q, processed&#10;        q += [vertex]&#10;        return vertex&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while q:&#10;        v = q.pop()&#10;        if not is_process(v): continue&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;        print(f&quot;process v={v}&quot;)&#10;                &#10;    return {}&#10;&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_,result)&#10;&#10;&#10;main_$bfs$()" description="DFS depth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
</templateSet>