<templateSet group="_ALGO">
  <template name="formap WHILE POP (GOOD dict iterate and delete element)" value="while $d0$:&#10;    print ($d0$.popitem())&#10;$END$    " description="while dict: popitem()" toReformat="false" toShortenFQNames="true">
    <variable name="d0" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for WHILE POP + result" value="result  = []&#10;while $left$ :&#10;    fst=$left$[0]&#10;    lst=$left$[-1]&#10;    result[:0] = [$left$.pop()]  &#10;&#10;$END$    " description="while list: pop()" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for WHILE POPLEFT DEQUEUE" value="result  = []&#10;arr=deque($left$)&#10;while arr :&#10;    fst=arr[0]&#10;    lst=arr[-1]&#10;    result+= [arr.popleft()]  &#10;&#10;$END$&#10;  " description="while dequeue: popleft()" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="func FILE read 1val" value="def file_to_array(filename):&#10;    result = []&#10;    for line in open(filename):&#10;        str=line.strip()&#10;        if not str:&#10;            continue&#10;        num=int(str)&#10;        assert isinstance(num,int), f&quot;NUM={num}&quot;&#10;        result.append(num)&#10;    print(&quot;Integers readed:&quot;,len(result) )&#10;    return result&#10;&#10;&#10;ARR4 = file_to_array(r'C:\Users\trans\Downloads\IntegerArray.txt')&#10;print(&quot;ARR4&gt;&gt;&quot;,ARR4[:3])&#10;&#10;&#10;&#10; " description="for line in open(filename)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graphic functions DRAW" value="import matplotlib.pyplot as plt&#10;from math import *&#10;&#10;F1 = [x ** 0.5 for x in range(1, 100)]&#10;F2 = [2 ** (log(x)) for x in range(1, 100)]&#10;F3 = [x ** (5/3) for x in range(1, 100)]&#10;&#10;fig, ax = plt.subplots()&#10;ax.plot(F1,color='black')&#10;ax.plot(F2,color='red')&#10;ax.plot(F3)&#10;plt.show()" description="matplotlib" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for FOR LIST" value="for i in range(0,len($P$)):&#10;    print($P$[i])" description="for i in range(len)" toReformat="false" toShortenFQNames="true">
    <variable name="P" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graph  undirected DRAW" value="import networkx as nx&#10;import matplotlib.pyplot as plt&#10;&#10;def draw_graph():&#10;    G = nx.Graph()&#10;    G.add_node(&quot;A&quot;)&#10;    G.add_node(&quot;B&quot;)&#10;    G.add_node(&quot;C&quot;)&#10;    G.add_node(&quot;D&quot;)&#10;    G.add_node(&quot;E&quot;)&#10;    G.add_node(&quot;F&quot;)&#10;    G.add_node(&quot;G&quot;)&#10;    G.add_edge(&quot;A&quot;, &quot;B&quot;)&#10;    G.add_edge(&quot;B&quot;, &quot;C&quot;)&#10;    G.add_edge(&quot;C&quot;, &quot;E&quot;)&#10;    G.add_edge(&quot;C&quot;, &quot;F&quot;)&#10;    G.add_edge(&quot;D&quot;, &quot;E&quot;)&#10;    G.add_edge(&quot;F&quot;, &quot;G&quot;)&#10;    plt.figure(figsize=(8, 8))&#10;    nx.draw(G)&#10;&#10;draw_graph()" description="networkx" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="OLD function GRAPHundirected  SUPER BFS lambda version" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, work=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$ return processed verticies&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return []&#10;    if not work: work = lambda x, y:None&#10;    if not start_vertex: start_vertex = next(iter(graph))&#10;    if not processed: processed = set()&#10;&#10;    q = []&#10;&#10;    def process(vertex_from, vertex_to):&#10;        nonlocal q, processed&#10;        if vertex_to in processed: return&#10;        processed |= {vertex_to}&#10;        q[:0] = [vertex_to]&#10;        print(f&quot; bfs process {vertex_from}-{vertex_to}&quot;)&#10;        work(vertex_from, vertex_to)&#10;&#10;    print(&quot;start verticle not processed=&quot;, start_vertex)&#10;    process(start_vertex, start_vertex) # ! no edge when start&#10;    while q:&#10;        v = q.pop()&#10;        for e in graph[v]:&#10;            process(v, e)&#10;&#10;    return processed&#10;&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_,result)&#10;&#10;&#10;main_$bfs$()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graph  undirected DRAW with labels" value="import networkx as nx&#10;import matplotlib.pyplot as plt&#10;&#10;&#10;&#10;def draw_graph(graph, labels_=None):&#10;    &quot;&quot;&quot;graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&quot;&quot;&quot;&#10;    if not labels_: labels_ = {}&#10;&#10;    g = nx.DiGraph()&#10;&#10;    for v in graph:&#10;        g.add_node(v)&#10;        label_additional = labels_.get(v, &quot;&quot;);&#10;        labels_[v] = f&quot;{v}  *{label_additional}*&quot;&#10;        for e in graph[v]:&#10;            try:&#10;                g.add_edge(v, e, w=graph[v][e])&#10;            except TypeError as error:&#10;                g.add_edge(v, e)&#10;&#10;    pos = nx.planar_layout(g)&#10;    # pos = nx.spring_layout(g)&#10;    nx.draw_networkx_nodes(g, pos)&#10;&#10;    nx.draw_networkx_labels(g, pos, labels=labels_)&#10;    nx.draw_networkx_edge_labels(g, pos)&#10;    nx.draw_networkx_edges(g, pos, edge_color='r', arrows=True)&#10;    plt.show()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="OLD function GRAPHundirected  SUPER DFS lambda version" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, work=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$  return processed verticies &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return []&#10;&#10;    if not work: work = lambda x:None&#10;    if not start_vertex: start_vertex = next(iter(graph))&#10;    if not processed: processed = set()&#10;&#10;    q = []&#10;&#10;    def is_process(vertex):&#10;        nonlocal q, processed&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        return True&#10;&#10;    will_process = lambda vertex: q.append(vertex)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while q:&#10;        v = q.pop()&#10;        if not is_process(v):&#10;            continue&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;        work(v)&#10;&#10;    return processed&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_,result)&#10;&#10;&#10;main_$bfs$()" description="DFS depth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  topological sort Kahns" value="##############################################################################################################################################################&#10;################# topological sort #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;def topo_sort(graph):&#10;    &quot;&quot;&quot; topo_sort &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return [],set()&#10;&#10;    stack_, processed, inputs, result = [], set(), defaultdict(int), []&#10;&#10;    # find for all vertices num of inputs edges&#10;    for v in graph:&#10;        for e in graph[v]:&#10;            inputs[e] += 1&#10;&#10;    # for cycled graph, downgrade to 0&#10;    min_ = min(inputs.values())&#10;    inputs = {k:v - min_ for k, v in inputs.items()}&#10;&#10;&#10;    stack_ += [v for v, i in inputs.items() if i &lt;= 0]&#10;    print(&quot;start form=&quot;, stack_)&#10;    while stack_:&#10;        v = stack_.pop()&#10;        for e in graph[v]:&#10;            inputs[e] -= 1&#10;            if not inputs[e]:&#10;                stack_ += [e]&#10;        print(f&quot;ts process v={v}&quot;)&#10;        result += [v]&#10;&#10;    return result,processed&#10;    &#10;" description="TS  algo/  ONLY FOR ACYCLIC" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="OLD function GRAPHundirected  shortest paths lambda version" value="def shortest_path2(graph):&#10;    &quot;&quot;&quot; shortest_path &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    lens = {v:inf for v in graph}&#10;    start_vertex, lens[start_vertex] = 1, 0&#10;    add_len = lambda x, y:lens.__setitem__(y, lens[x] + 1)&#10;    # debug_len = lambda y, x:print(&quot;debug&quot;, x, y)&#10;    bfs(graph, start_vertex, add_len)&#10;&#10;    return lens&#10;&#10; " description="lens of verticies" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="OLD function GRAPHundirected  weak connected conponents lambda version" value="def undirected_connected_components2(graph):&#10;    &quot;&quot;&quot; undirected_connected_components &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    processed, connectings, counter = set(), {}, 0&#10;    set_counter = lambda x, y:connectings.__setitem__(y, counter)&#10;&#10;    for w in graph:&#10;        if w in processed: continue&#10;        counter += 1&#10;        processed |= bfs(graph, w, set_counter, processed)&#10;        print(&quot;PROCESSED=&quot;, processed)&#10;&#10;    return connectings&#10;&#10; " description="lens of verticies" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="OLD function GRAPHdirected connected conponents STRONG lambda version" value="def revers(graph):&#10;    &quot;&quot;&quot; revers &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    result = {v:[] for v in graph}&#10;    for v in graph:&#10;        for e in graph[v]:&#10;            result[e] += [v]&#10;&#10;    return result&#10;&#10;&#10;def kesaray(graph):&#10;    &quot;&quot;&quot; kesaray  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    # first stage of keserayo algo&#10;    reversed_ = revers(graph)&#10;    sorted_ = topo_sort(reversed_)&#10;    print(&quot;GRAPH&quot;, graph)&#10;&#10;    processed, result, counter, f = set(), {}, 0, lambda v:result.setdefault(v, counter)&#10;&#10;    for w in sorted_:&#10;        if w in processed: continue&#10;        counter += 1&#10;        processed |= dfs(graph, w, f, processed)&#10;        print(f&quot;&gt;&gt; processed={processed} result={result}&quot;)&#10;&#10;    return result&#10;&#10;&#10;# ????&#10;def metagraph(table):&#10;    res = {v:[] for v in set(table.values())}&#10;    for v, w in table.items():&#10;        res[w] += [v]&#10;    return res" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="OLD function GRAPHundirected  SUPER DFS v2" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$ return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    stack_, processed, start_vertex, result = [], processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    def is_process(vertex):&#10;        nonlocal processed&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        return True&#10;&#10;    will_process = lambda vertex:stack_.append(vertex)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while stack_:&#10;        v = stack_.pop()&#10;        if not is_process(v): continue&#10;        if v not in graph: print(&quot;!! vertix not exists in first column of graph table:&quot;, v); continue&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;        result += [v]&#10;&#10;    return result, processed&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;main_$bfs$()" description="DFS depth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER BFS 3bad" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, processed=None, both_vertex=False):&#10;    &quot;&quot;&quot; $bfs$ return ordered(vertix_from,vertix_to) and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return [], []&#10;&#10;    queue_, start_vertex, processed, result = [], start_vertex or next(iter(graph)), processed or set(), []&#10;&#10;    def process(vertex_from, vertex_to):&#10;        nonlocal queue_, processed, result&#10;        if vertex_to in processed: return&#10;        processed |= {vertex_to}&#10;        queue_[:0] = [vertex_to]&#10;        print(f&quot; bfs process {vertex_from}-{vertex_to}&quot;)&#10;        if both_vertex:&#10;            result += [(vertex_from, vertex_to)]&#10;        else:&#10;            result += [vertex_to]    &#10;&#10;    print(&quot;start verticle not processed=&quot;, start_vertex)&#10;    process(start_vertex, start_vertex)  # ! no edge when start&#10;    while queue_:&#10;        v = queue_.pop()&#10;        for e in graph[v]:&#10;            process(v, e)&#10;&#10;    return result, processed&#10;&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;main_$bfs$()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  shortest paths" value="def shortest_path2(graph,start_vertex):&#10;    &quot;&quot;&quot; shortest_path &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    lens = defaultdict(lambda:inf)&#10;    lens[start_vertex] =  0&#10;&#10;    traversed, _ = bfs(graph, start_vertex)  #нужно модифицировать BFS чтобы возвращал (vartix_from, vertix_to)&#10;    for v, e in traversed: lens[e] = lens[v] + 1&#10;&#10;    return lens&#10;&#10; " description="lens of verticies" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected connected conponents UNDIRECTED" value="def undirected_connected_components2(graph):&#10;    &quot;&quot;&quot; undirected_connected_components &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    processed, ccomponents, counter = set(), {}, 0&#10;&#10;    for w in graph:&#10;        if w in processed: continue&#10;        counter += 1&#10;        traversed, processed =dfs(graph, w, processed)&#10;        for v in traversed: ccomponents[v]=counter&#10;&#10;    return ccomponents&#10;&#10; " description="lens of verticies" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected  strong  connected conponents" value="def revers(graph):&#10;    &quot;&quot;&quot; direction of all edges reversed  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    result = defaultdict(list)&#10;    for v in graph:&#10;        for e in graph[v]:&#10;            result[e] += [v]&#10;&#10;    return result&#10;&#10;&#10;def metagraph(table):&#10;    &quot;&quot;&quot; swap keys and values &quot;&quot;&quot;&#10;    res = defaultdict(list)&#10;    for v, w in table.items():&#10;        res[w] += [v]&#10;    return res&#10;    &#10;&#10;def kesaray(graph):&#10;    &quot;&quot;&quot; kesaray  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    # first stage of keserayo algo&#10;    reversed_ = revers(graph)&#10;    topo_sorted = topo_sort(reversed_)&#10;    print(&quot;GRAPH&quot;, graph)&#10;&#10;    # dfs/bfs - second stage of kesarayo algo&#10;    processed, result, counter = set(), {}, 0&#10;    for w in topo_sorted:&#10;        if w in processed: continue&#10;        counter += 1&#10;        traversed, processed = dfs(graph, w, processed)&#10;        for v in traversed: result.setdefault(v, counter)&#10;&#10;    return result&#10;&#10;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  topological sort SUPER  recursion classic" value="##############################################################################################################################################################&#10;################# topological sort #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;def topo_sort3(graph, processed=None):&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], set()&#10;&#10;    processed, result, counter = processed or set(), {}, l&#10;&#10;    def process(vertex):&#10;        nonlocal processed&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        return True&#10;&#10;    def dfss(vertex):&#10;        nonlocal counter&#10;        process(vertex)&#10;        for e in graph[vertex]:&#10;            if e not in processed:&#10;                dfss(e)&#10;        print(f&quot; dfs3processed={vertex}={counter}&quot;)&#10;        result[vertex] = counter&#10;        counter -= 1&#10;&#10;    for w in graph:&#10;        if w in processed: continue&#10;        dfss(w)&#10;&#10;    result2 = [k for k, v in sorted(result.items(), key=lambda e:e[1])]&#10;    return result2, processed&#10;    &#10;" description="TS  algo/ DFS recursion /  FOR CYCLIC" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected topological sort STACK 2" value="def topo_sort2(graph, processed=None):&#10;    &quot;&quot;&quot; dfs return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], set()&#10;&#10;    stack_, processed, result, counter = [], processed or set(), {}, l&#10;&#10;    def process(vertex):&#10;        nonlocal processed, stack_&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        stack_ += [vertex]&#10;        return True&#10;&#10;    for w in graph:&#10;        if not process(w): continue&#10;&#10;        while stack_:&#10;            v = stack_.pop()&#10;&#10;            if v &gt;= 0:&#10;                stack_ += [-v - 1] # TRICK: add for post processing later&#10;                for e in graph[v]:&#10;                    process(e) &#10;            else:&#10;                vertex = -v - 1  # initial vertex when pushed&#10;                result[vertex] = counter&#10;                counter -= 1&#10;&#10;    result2 = [k for k, v in sorted(result.items(), key=lambda e:e[1])]&#10;    return result2, processed&#10;    &#10;" description="TS  algo/ double push /  FOR CYCLIC" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected topological sort STACK  1" value="def topo_sort2(graph, processed=None):&#10;    &quot;&quot;&quot; dfs return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], set()&#10;&#10;    stack_, processed, result, counter = [], processed or set(), {}, l&#10;    stack_2 = []&#10;&#10;    def is_process(vertex):&#10;        nonlocal processed&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        print(&quot;is_process:&quot;, vertex, stack_)&#10;        return True&#10;&#10;    def will_process(vertex):&#10;        nonlocal stack_&#10;        stack_.append(vertex)&#10;        print(&quot;will_process:&quot;, vertex, stack_)&#10;&#10;    for w in graph:&#10;        if w in processed: continue&#10;&#10;        print(&quot;start from&quot;, w)&#10;        will_process(w)&#10;        while stack_2 + stack_:&#10;            v = stack_.pop() if stack_ else stack_2.pop()&#10;            if not is_process(v): continue&#10;&#10;            if v &gt;= 0:&#10;                stack_2 += [-v - 1]  # TRICK: add for post processing later&#10;&#10;                for e in graph[v]:&#10;                    will_process(e)&#10;            else:&#10;                vertex = -v - 1  # initial vertex when pushed&#10;                print(f&quot;RESULT {vertex}={counter}&quot;)&#10;                result[vertex] = counter&#10;                counter -= 1&#10;&#10;    result2 = [k for k, v in sorted(result.items(), key=lambda e:e[1])]&#10;    return result2, processed&#10;    &#10;" description="TS  algo/ double push /  FOR CYCLIC" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER DFS  1" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$ return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    stack_, processed, start_vertex, result = [], processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    def is_process():&#10;        nonlocal processed&#10;        vertex = stack_.pop()&#10;        if vertex in processed: return None&#10;        processed |= {vertex}&#10;        return vertex&#10;&#10;    will_process = lambda vertex:stack_.append(vertex)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while stack_:&#10;        if not (v := is_process()): continue&#10;        if v not in graph: print(&quot;!! vertix not exists in first column of graph table:&quot;, v); continue&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;        result += [v]&#10;&#10;    return result, processed&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;main_$bfs$()" description="DFS depth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected Dijkstra var2 base" value="def dijkstra(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; dijkstra return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    costs, parents, processed, start_vertex, result = {k:inf for k, v in graph.items()}, {}, processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    def process():&#10;        nonlocal processed&#10;        # // это обязательно так как если этого не сделать то обязательно найдется минимальный элемент даже если и обрабатывать нечего&#10;        if not graph.keys() - processed: return None&#10;        vertex, cost = min(costs.items(), key=lambda e:e[1] if e[0] not in processed else inf)&#10;        # //если находится только бесконечность то означает что идти больше некуда&#10;        if cost &gt;= inf: return None&#10;        processed |= {vertex}&#10;        return vertex&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    costs[start_vertex] = 0&#10;&#10;    while v := process():&#10;        for n, c in graph[v].items():&#10;            new_cost = costs[v] + c&#10;            if costs[n] &gt; new_cost:&#10;                costs[n] = new_cost&#10;                parents[n] = v&#10;        print(f&quot;dfs process v={v}&quot;)&#10;&#10;    p = {v:k for k, v in parents.items()}&#10;    next_vertex = start_vertex&#10;    result += start_vertex&#10;    while next_vertex := p.pop(next_vertex, None):&#10;        result += next_vertex&#10;&#10;    return result, processed&#10;&#10;&#10;def dijkstra_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;&#10;    input_ = graph_weighed&#10;    result = dijkstra(input_, 't')&#10;    print(&quot;MAIN bfs: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;dijkstra_main()" description="O=V*E" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="formap PARENT_TABLE WHILE pop C-STYLE pop" value="result=[]    &#10;next_vertex = start_vertex&#10;result += start_vertex&#10;while next_vertex := $d0$.pop(next_vertex, None):&#10;    result += next_vertex    &#10;    &#10;$END$    " description="while next=pop(next):   # iterate over network" toReformat="false" toShortenFQNames="true">
    <variable name="d0" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="formap WHILE POP C-STYLE" value="while e:=$d0$.popitem() if $d0$ else None:&#10;    print (e)&#10;$END$&#10;" description="while popitem():" toReformat="false" toShortenFQNames="true">
    <variable name="d0" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for WHILE POP C-STYLE" value="while i:=$left$.pop() if $left$ else None:&#10;    print(i)&#10;    &#10;$END$    " description="while pop():" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for WHILE POP HEAP" value="while i := heappop($left$) if $left$ else None:&#10;    print(i)&#10;    &#10;$END$&#10;  " description="while heappop:" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="BAD function GRAPHdirected Dijkstra" value="##############################################################################################################################################################&#10;################# dijkstra #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def dijkstra(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; dijkstra return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    costs, parents, processed, start_vertex, result = {k:inf for k, v in graph.items()}, {}, processed or set(), start_vertex or next(iter(graph)), []&#10;    heap = []&#10;&#10;    def will_process(vertex, cost):&#10;        nonlocal processed&#10;        if vertex in processed: return&#10;        processed |= {vertex}&#10;        heappush(heap, (cost, vertex))&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    costs[start_vertex] = 0&#10;    heappush(heap, (0, start_vertex))&#10;    while v := heappop(heap) if heap else None:&#10;        vertex = v[1]&#10;        for n, c in graph[vertex].items():&#10;            new_cost = costs[vertex] + c&#10;            if costs[n] &gt; new_cost:&#10;                costs[n] = new_cost&#10;                parents[n] = vertex&#10;                will_process(n, new_cost)&#10;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;&#10;    print(costs, parents)&#10;    p = {v:k for k, v in parents.items()}&#10;    next_vertex = start_vertex&#10;    result += start_vertex&#10;    while next_vertex := p.pop(next_vertex, None):&#10;        result += next_vertex&#10;&#10;    return result, processed&#10;&#10;&#10;def dijkstra_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;&#10;    input_ = graph_weighed&#10;&#10;    print(&quot;MAIN bfs1: &quot;, dijkstra(input_, 's'))&#10;    print(&quot;MAIN bfs2: &quot;, dijkstra(input_, 't'))&#10;    draw_graph(input_)&#10;&#10;&#10;dijkstra_main()" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected Dijkstra  var2 heap" value="def dijkstra(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; dijkstra return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    costs, parents, processed, start_vertex, result = {k:inf for k, v in graph.items()}, {}, processed or set(), start_vertex or next(iter(graph)), []&#10;    costs[start_vertex] = 0&#10;    heap = Heap([[v, k] for k, v in costs.items()])&#10;&#10;    print(&quot;heap:&quot;, heap)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    while v := heap.pop():&#10;        processed |= {v}&#10;        for n, c in graph[v].items():&#10;            if n not in heap.entry_finder: continue # based on hash-set O=1&#10;            new_cost = costs[v] + c&#10;            if costs[n] &gt; new_cost:&#10;                costs[n] = new_cost&#10;                parents[n] = v&#10;                heap.push(new_cost, n)&#10;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;&#10;    p = {v:k for k, v in parents.items()}&#10;    next_vertex = start_vertex&#10;    result += [start_vertex]&#10;    while next_vertex := p.pop(next_vertex, None):&#10;        result += [next_vertex]&#10;&#10;    return result, processed&#10;&#10;&#10;def dijkstra_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;&#10;    input_ = graph_weighed&#10;&#10;    print(&quot;MAIN bfs1: &quot;, dijkstra(input_, 's'))&#10;    print(&quot;MAIN bfs2: &quot;, dijkstra(input_, 't'))&#10;    draw_graph(input_)&#10;&#10;&#10;dijkstra_main()" description="O=V+E*log V с ненужным массивом processed" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected Dijkstra var1 base" value="def dijkstra1(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; dijkstra return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    costs, parents, processed, start_vertex, result = {k:inf for k, v in graph.items()}, {}, processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    def process():&#10;        nonlocal processed&#10;        itog = {v:e for v, e in costs.items() if v not in processed}&#10;        if not len(itog): return None&#10;        vertex, cost = min(itog.items(), key=lambda e:e[1])&#10;        processed |= {vertex}&#10;        return vertex&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    costs[start_vertex] = 0&#10;&#10;    while v := process():&#10;        for n, c in graph[v].items():&#10;            new_cost = costs[v] + c&#10;            if costs[n] &gt; new_cost:&#10;                costs[n] = new_cost&#10;                parents[n] = v&#10;        print(f&quot;dfs process v={v}&quot;)&#10;&#10;    p = {v:k for k, v in parents.items()}&#10;    next_vertex = start_vertex&#10;    result += start_vertex&#10;    while next_vertex := p.pop(next_vertex, None):&#10;        result += next_vertex&#10;&#10;    return result, processed&#10;&#10;&#10;def dijkstra1_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;&#10;    input_ = graph_weighed&#10;    result = dijkstra1(input_, 't')&#10;    print(&quot;MAIN bfs: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;dijkstra1_main()&#10;" description="O=V*E" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER BFS 2" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$ return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    stack_, processed, start_vertex, result = [], processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    def is_process():&#10;        nonlocal processed&#10;        vertex = stack_.pop()&#10;        if vertex in processed: return None&#10;        processed |= {vertex}&#10;        return vertex&#10;&#10;    will_process = lambda vertex:stack_.insert(1,vertex)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while stack_:&#10;        if not (v := is_process()): continue&#10;        if v not in graph: print(&quot;!! vertix not exists in first column of graph table:&quot;, v); continue&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;        result += [v]&#10;&#10;    return result, processed&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;main_$bfs$()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER BFS 1" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$ return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    stack_, processed, start_vertex, result = [], processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    will_process = lambda vertex:stack_.append(vertex)&#10;    #will_process = lambda vertex:stack_.insert(0, vertex)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while v := (stack_.pop() if stack_ else None):&#10;        if v in processed: continue&#10;        processed |= {v}&#10;&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;            # ЕСЛИ НУЖНО ВОЗВРАЩАТЬ ДВЕ ВЕРШИНЫ ТО ДОБАВИМ ЗДЕСЬ result += [(v, e)]&#10;            &#10;        print(f&quot;dfs process v={v}&quot;)&#10;        result += [v]&#10;&#10;    return result, processed&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;main_$bfs$()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="func FILE read 2val" value="def $file_to_array$(filename):&#10;    result = []&#10;    skip_first=True&#10;    for line in open(filename):&#10;        str = line.strip()&#10;        if not str: continue&#10;&#10;        if skip_first: skip_first=False; continue&#10;        w_, l_ = str.strip().split(&quot; &quot;)&#10;        w, l = int(w_.strip()), int(l_.strip())&#10;        assert isinstance(w, int), f&quot;NUM1={w}&quot;&#10;        assert isinstance(l, int), f&quot;NUM2={l}&quot;&#10;        result.append((w,l))&#10;    print(&quot;Integers readed:&quot;, len(result))&#10;    return result&#10;&#10;&#10;arr = $file_to_array$(r'C:\Users\trans\Downloads\IntegerArray.txt')&#10;print(&quot;ARR4&gt;&gt;&quot;,arr)" description="for line in open(filename)" toReformat="false" toShortenFQNames="true">
    <variable name="file_to_array" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GREEDY schedule 2 queue" value="def file_to_array1(filename):&#10;    result = []&#10;    skip_first = True&#10;    for line in open(filename):&#10;        str = line.strip()&#10;        if not str: continue&#10;&#10;        if skip_first: skip_first = False; continue&#10;        w_, l_ = str.strip().split(&quot; &quot;)&#10;        w, l = int(w_.strip()), int(l_.strip())&#10;        assert isinstance(w, int), f&quot;NUM1={w}&quot;&#10;        assert isinstance(l, int), f&quot;NUM2={l}&quot;&#10;        result.append((w, l))&#10;    print(&quot;Integers readed:&quot;, len(result))&#10;    return result&#10;&#10;&#10;def greedy_schedule(tasks):&#10;    list_ = [(round(w / l, 2), w, l) for w, l in tasks]&#10;    list_.sort(key=lambda e:e[0])  # sorted from min-&gt;max than pop() from max&#10;    #print(&quot;sorted:&quot;, list_)&#10;    sum = 0&#10;    term = 0&#10;    while e := list_.pop() if list_ else None:&#10;        term += e[2]&#10;        sum += e[1] * term&#10;        #print(f&quot;&gt;&gt; {term} {sum}&quot;)&#10;    return sum&#10;&#10;def greedy_main():&#10;    arr = file_to_array1(r'problem13.4.txt')&#10;    #arr = file_to_array1(r'problem.txt')&#10;    #print(arr)&#10;    print(&quot;ARR4&gt;&gt;&quot;, greedy_schedule(arr))&#10;&#10;&#10;greedy_main()&#10;&#10;&#10;" description="minimize weightned sum problem" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GREEDY schedule 1 for_list" value="def file_to_array1(filename):&#10;    result = []&#10;    skip_first = True&#10;    for line in open(filename):&#10;        str = line.strip()&#10;        if not str: continue&#10;&#10;        if skip_first: skip_first = False; continue&#10;        w_, l_ = str.strip().split(&quot; &quot;)&#10;        w, l = int(w_.strip()), int(l_.strip())&#10;        assert isinstance(w, int), f&quot;NUM1={w}&quot;&#10;        assert isinstance(l, int), f&quot;NUM2={l}&quot;&#10;        result.append((w, l))&#10;    print(&quot;Integers readed:&quot;, len(result))&#10;    return result&#10;&#10;&#10;def greedy_schedule(tasks):&#10;    list_ = [(round(w / l, 2), w, l) for w, l in tasks]&#10;    list_.sort(key=lambda e:e[0], reverse=True) # from max to min&#10;    # print(&quot;sorted:&quot;, list_)&#10;    sum = 0&#10;    term = 0&#10;    for _, w, l in list_:&#10;        term += l&#10;        sum += w * term  &#10;    # print(f&quot;&gt;&gt; {term} {sum}&quot;)&#10;    return sum&#10;&#10;def greedy_main():&#10;    arr = file_to_array1(r'problem13.4.txt')&#10;    #arr = file_to_array1(r'problem.txt')&#10;    #print(arr)&#10;    print(&quot;ARR4&gt;&gt;&quot;, greedy_schedule(arr))&#10;&#10;&#10;greedy_main()&#10;&#10;&#10;" description="minimize weightned sum problem" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected Dijkstra  var1 heap" value="def dijkstra(graph, start_vertex=None ):&#10;    &quot;&quot;&quot; dijkstra return ordered  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return []&#10;&#10;    costs, parents, start_vertex, result = {k:inf for k, v in graph.items()}, {}, start_vertex or next(iter(graph)), []&#10;    costs[start_vertex] = 0&#10;    heap = Heap([[v, k] for k, v in costs.items()])&#10;&#10;    print(&quot;heap:&quot;, heap)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    while v := heap.pop():&#10;        for n, c in graph[v].items():&#10;            if n not in heap.entry_finder: continue  # find-operation based on hash-set O=1&#10;            new_cost = costs[v] + c&#10;            if costs[n] &gt; new_cost:&#10;                costs[n] = new_cost&#10;                parents[n] = v&#10;                heap.push(new_cost, n)&#10;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;&#10;    p = {v:k for k, v in parents.items()}&#10;    next_vertex = start_vertex&#10;    result += [start_vertex]&#10;    while next_vertex := p.pop(next_vertex, None):&#10;        result += [next_vertex]&#10;&#10;    return result&#10;&#10;&#10;def dijkstra_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;&#10;    input_ = graph_weighed&#10;&#10;    print(&quot;MAIN bfs1: &quot;, dijkstra(input_, 's'))&#10;    print(&quot;MAIN bfs2: &quot;, dijkstra(input_, 't'))&#10;    draw_graph(input_)&#10;&#10;&#10;dijkstra_main()" description="O=V+E*log V" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  MST1 dijkstra" value="def mst1_prima(graph, start_vertex=None):&#10;    &quot;&quot;&quot; mst based on dijkstra return  MST-graph  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return []&#10;&#10;&#10;    costs, parents, start_vertex, result = {k:inf for k, v in graph.items()}, {}, start_vertex or next(iter(graph)), []&#10;    costs[start_vertex] = 0&#10;    heap = Heap([[v, k] for k, v in costs.items()])&#10;&#10;    print(&quot;heap:&quot;, heap)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    while v := heap.pop():&#10;        for n, c in graph[v].items():&#10;            if n not in heap.entry_finder: continue&#10;            new_cost = c # единственное отличие от алгоритма Дейкстры&#10;            if new_cost &lt; costs[n]:&#10;                costs[n] = new_cost&#10;                parents[n] = v&#10;                heap.push(new_cost, n)&#10;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;&#10;&#10;    return parents&#10;&#10;&#10;def mst1_prima_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;    graph_mst = dict(a=dict(b=1, c=4, d=3), b=dict(a=1, d=2), c=dict(a=4, d=5), d=dict(b=2, c=5, a=3))&#10;&#10;    input_ = graph_mst&#10;&#10;    print(&quot;MAIN bfs1: &quot;, mst1_prima(input_, 'a'))&#10;    print(&quot;MAIN bfs2: &quot;, mst1_prima(input_, 'd'))&#10;    draw_graph(input_)&#10;&#10;&#10;mst1_prima_main()" description="Prima's algo (Dijkstra) minimum spanning tree O=V+E*log V" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="formap PARENT_TABLE WHILE pop C-STYLE   iter" value="next_vertex = start_vertex&#10;while next_parent := $d0$.get(next_vertex):  # get=None if absent&#10;    if next_vertex == next_parent: return next_parent&#10;    next_vertex = next_parent&#10;         &#10;$END$    " description="while next=get(next):   # iterate over network" toReformat="false" toShortenFQNames="true">
    <variable name="d0" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  MST2 union-find" value="@dataclass&#10;class Parent:&#10;    parent: Any&#10;    size: int&#10;&#10;&#10;class UnionFind():&#10;    &quot;&quot;&quot; structure for Kraskal's MST graphs&#10;&#10;        obj1 = UnionFind([1, 2, 3, 4])&#10;        p1 = obj1.find(1)&#10;        p2 = obj1.find(2)&#10;        print(obj1)&#10;        obj1.union(p1, p2)&#10;        print(obj1)&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, list_):&#10;        if not list_: raise ValueError(&quot;Constructor's argument must not be empty.&quot;)&#10;        assert isinstance(list_, list)&#10;&#10;        self.__table = {o:Parent(o, 1) for o in list_}&#10;&#10;    def find(self, object_):&#10;        &quot;&quot;&quot; find some object in sets and return set (Parent object)&quot;&quot;&quot;&#10;        if object_ not in self.__table: return None&#10;&#10;        next_vertex = object_&#10;        while next_parent := self.__table.get(next_vertex):&#10;            if next_vertex == next_parent.parent: return next_parent&#10;            next_vertex = next_parent.parent&#10;&#10;    def union(self, parent1, parent2):&#10;        &quot;&quot;&quot; union two sets(Parent objects) into one set &quot;&quot;&quot;&#10;        if not parent1 or not parent2: raise ValueError(&quot;arguments must not be empty.&quot;)&#10;        assert isinstance(parent1, Parent)&#10;        assert isinstance(parent2, Parent)&#10;&#10;        if parent1.size &lt;= parent2.size:&#10;            parent2.parent = parent1.parent&#10;            parent1.size += parent2.size&#10;        else:&#10;            parent1.parent = parent2.parent&#10;            parent2.size += parent1.size&#10;&#10;    def __repr__(self):&#10;        return f&quot;{self.__table}&quot;&#10;&#9;&#9;&#10;&#10;def mst_kraskal(graph, start_vertex=None):&#10;    &quot;&quot;&quot; mst based on dijkstra return  MST-graph  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], 0&#10;&#10;    costs, parents, start_vertex, result = [(v1, v2, cost) for v1, dict1 in graph.items() for v2, cost in dict1.items()], {}, start_vertex or next(iter(graph)), []&#10;    costs.sort(key=lambda e:e[2])&#10;&#10;    sets = UnionFind(list(graph))&#10;    for e1, e2, cost in costs:&#10;        if (s1 := sets.find(e1)) is not (s2 := sets.find(e2)):&#10;            sets.union(s1, s2)&#10;            result += [(e1, e2, cost)]&#10;&#10;    sum_ = sum(v for _, _, v in result)&#10;    return result, sum_&#10;&#10;&#10;def mst_kraskal_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;    graph_mst = dict(a=dict(b=1, c=4, d=3), b=dict(a=1, d=2), c=dict(a=4, d=5), d=dict(b=2, c=5, a=3))&#10;&#10;    # input_ = mst_grap_load(r'edges.txt')&#10;    input_ = graph_mst&#10;&#10;    print(&quot;MAIN bfs1: &quot;, mst_kraskal(input_))  # -3612829&#10;    # print(&quot;MAIN bfs2: &quot;, mst1_prima(input_, 'd'))&#10;    draw_graph(input_)&#10;&#10;&#10;mst_kraskal_main()&#10;&#9;" description="Kraskal's algo (UnionFind) minimum spanning tree O=V+E*log V" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  MST clustering" value="##############################################################################################################################################################&#10;################# clustering1 #############################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def dfs(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; dfs return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    stack_, processed, start_vertex, result = [], processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    def is_process():&#10;        nonlocal processed&#10;        vertex = stack_.pop()&#10;        if vertex in processed: return None&#10;        processed |= {vertex}&#10;        return vertex&#10;&#10;    will_process = lambda vertex:stack_.append(vertex)&#10;&#10;    # print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while stack_:&#10;        if not (v := is_process()): continue&#10;        if v not in graph: print(&quot;!! vertix not exists in first column of graph table:&quot;, v); continue&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;        # print(f&quot;dfs process v={v}&quot;)&#10;        result += [v]&#10;&#10;    return result, processed&#10;&#10;&#10;def undirected_connected_components2(graph):&#10;    &quot;&quot;&quot; undirected_connected_components &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    processed, ccomponents, counter = set(), [], 0&#10;&#10;    for w in graph:&#10;        if w in processed: continue&#10;        counter += 1&#10;        traversed, processed = dfs(graph, w, processed)&#10;        ccomponents += [traversed]  # for v in traversed: ccomponents[v]=counter&#10;&#10;    return ccomponents&#10;&#10;&#10;##############################################################################################################################################################&#10;################# clustering2 #############################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def split_sets_into_clusters(sets):&#10;    g = {v1:[p.parent] for v1, p in sets._UnionFind__table.items()}&#10;    return undirected_connected_components2(g)&#10;&#10;&#10;def mst_kraskal_clustering(graph, k=1, start_vertex=None):&#10;    &quot;&quot;&quot; mst based on dijkstra return  MST-graph  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return None, 0&#10;&#10;    costs, parents, start_vertex, result = [(v1, v2, cost) for v1, dict1 in graph.items() for v2, cost in dict1.items()], {}, start_vertex or next(iter(graph)), []&#10;    costs.sort(key=lambda e:e[2])&#10;&#10;    sets = UnionFind(list(graph))&#10;    for e1, e2, cost in costs:&#10;        if (s1 := sets.find(e1)) is not (s2 := sets.find(e2)):&#10;            if len(result) &gt;= l - k: return sets, cost&#10;            sets.union(s1, s2)&#10;            result += [(e1, e2, cost)]&#10;&#10;    return sets, 0&#10;&#10;&#10;def mst_kraskal_clustering_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;    graph_mst = dict(a=dict(b=1, c=4, d=3), b=dict(a=1, d=2), c=dict(a=4, d=5), d=dict(b=2, c=5, a=3))&#10;&#10;    input_ = mst_grap_load(r'clustering1.txt')&#10;    #input_ = graph_mst&#10;&#10;    result, dist = mst_kraskal_clustering(input_, 4) # =106&#10;    result2 = split_sets_into_clusters(result)&#10;    print(&quot;MAIN dist    : &quot;, dist)&#10;    print(&quot;MAIN sets    : &quot;, result)  # -3612829&#10;    print(&quot;MAIN clusters: &quot;, result2)&#10;&#10;    draw_graph(input_)&#10;&#10;&#10;mst_kraskal_clustering_main()" description="Kraskal's algo (UnionFind) minimum spanning tree O=V+E*log V" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected create GRAPH from PARENT_TABLE 2" value="g = {v1:[p.parent] for v1, p in sets._UnionFind__table.items()}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function Huffman" value="##############################################################################################################################################################&#10;################# bfs  #############################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;def bfs(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; bfs return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    stack_, processed, start_vertex, result = [], processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    will_process = lambda vertex:stack_.append(vertex)&#10;    # will_process = lambda vertex:stack_.insert(0, vertex)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while v := (stack_.pop() if stack_ else None):&#10;        if v in processed: continue&#10;        processed |= {v}&#10;&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;            result += [(v, e)]  # print(f&quot;dfs process v={v}&quot;)&#10;&#10;    return result, processed&#10;&#10;&#10;def shortest_path2(graph, start_vertex):&#10;    &quot;&quot;&quot; shortest_path &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    lens = defaultdict(lambda:inf)&#10;    lens[start_vertex] = 0&#10;&#10;    traversed, _ = bfs(graph, start_vertex)&#10;    for v, e in traversed: lens[e] = lens[v] + 1&#10;&#10;    return lens&#10;&#10;##############################################################################################################################################################&#10;################# hoffman  #############################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;def file_hofman(filename):&#10;    result = []&#10;    skip_first = True&#10;    for line in open(filename):&#10;        str = line.strip()&#10;        if not str: continue&#10;&#10;        if skip_first: skip_first = False; continue&#10;&#10;        w = int(str)&#10;        assert isinstance(w, int), f&quot;NUM1={w}&quot;&#10;&#10;        result.append(w)&#10;    print(&quot;Integers readed:&quot;, len(result))&#10;    return result&#10;&#10;&#10;@dataclass(order=True)&#10;class Parend:&#10;    parent: Any = field(compare=False)&#10;    weight: int&#10;&#10;&#10;def hoffman(alphavet):&#10;    parent_table, heap, result_graph, root_node = {}, [], defaultdict(list), &quot;&quot;&#10;    for i, e in enumerate(alphavet):&#10;        p = Parend(str(i), e)&#10;        parent_table[str(i)] = p&#10;        heap += [p]&#10;&#10;    heapify(heap)&#10;    counter = itertools.count()  # unique sequence count&#10;    while len(heap) &gt;= 2:&#10;        e1 = heappop(heap)&#10;        e2 = heappop(heap)&#10;        # create new node&#10;        new_node_name = root_node = &quot;NEW&quot; + str(next(counter))&#10;        p = Parend(new_node_name, e1.weight + e2.weight)&#10;        # update existing nodes&#10;        e1.parent = e2.parent = new_node_name&#10;        # add new node&#10;        heappush(heap, p)&#10;        parent_table[new_node_name] = p&#10;&#10;    for e, p in parent_table.items():&#10;        result_graph[p.parent] += [e]&#10;&#10;    print(&quot;HEAP:&quot;, heap)&#10;    print(&quot;parent table:&quot;, parent_table)&#10;&#10;    return result_graph, root_node&#10;&#10;&#10;def hoffman_main():&#10;    arr = file_hofman(r'problem14.6.txt')&#10;    result, root = hoffman(arr)&#10;    lens = shortest_path2(result, root)&#10;&#10;    lens1= {k:v for k,v in lens.items() if not k.startswith(&quot;NEW&quot;)}&#10;    print(&quot;ARR4&gt;&gt;&quot;, min(lens1.values()), max(lens.values()))  # OTVET= 9 19&#10;&#10;    draw_graph(result)&#10;&#10;hoffman_main()" description="Huffman Codes построение дерева кодов для данного алфавита" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="formap PARENT_TABLE create graph from 1" value="    parent_table, result_graph = {},  defaultdict(list)&#10;&#10;    for e, p in parent_table.items():&#10;        result_graph[p.parent] += [e]" description="for e, p in parent_table.items():" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="formap PARENT_TABLE create graph from 2" value="g = {v1:[p.parent] for v1, p in sets._UnionFind__table.items()}" description="{v1:[p.parent] for v1, p in sets._UnionFind__table.items()}" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected BelmanFord" value="def find_negative_cycle(graph, costs, parents):&#10;    negative_edges = []&#10;&#10;    # еще одна итерация и найдем ребра которые постоянно уменьшаются&#10;    for v in graph:&#10;        for n, c in graph[v].items():&#10;            new_cost = costs[v] + c&#10;            if costs[n] &gt; new_cost:&#10;                negative_edges += [(v, n)]&#10;&#10;    if not negative_edges: return []&#10;&#10;    # так как найденное ребро не обязательно входит в цикл но может быть достижимо из него &#10;    # поэтому найдем вершину которая 100% будет входит в отрицательный цикл&#10;    visited, x = {}, negative_edges[0][1]&#10;    while not visited.get(x):&#10;        visited[x] = True&#10;        x = parents[x]&#10;&#10;    # найдем сам цикл&#10;    cycle, v = [x], parents[x]  # vertex from negative cycle&#10;    while v != x:&#10;        cycle += [v]&#10;        v = parents[v]&#10;    print(&quot;cyclee:&quot;, cycle)&#10;    return cycle&#10;&#10;&#10;def belmanFord(graph, start_vertex=None):&#10;    costs, parents, start_vertex, result = {k:inf for k, v in graph.items()}, {}, start_vertex or next(iter(graph)), []&#10;    costs[start_vertex] = 0&#10;    l = len(graph)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    for _ in range(l - 1):&#10;        for v in graph:&#10;            for n, c in graph[v].items():&#10;                new_cost = costs[v] + c&#10;                if costs[n] &gt; new_cost:&#10;                    costs[n] = new_cost&#10;                    parents[n] = v&#10;&#10;    find_negative_cycle(graph, costs, parents)&#10;&#10;    p = {v:k for k, v in parents.items()}&#10;    next_vertex = start_vertex&#10;    result += [start_vertex]&#10;    while next_vertex := p.pop(next_vertex, None):&#10;        result += [next_vertex]&#10;&#10;    print(&quot;costs&quot;, costs)&#10;    return result&#10;&#10;&#10;def main_belmanFord():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;&#10;    #@formatter:off&#10;    graph_weighed = dict(s=dict(v=1, w=4),&#10;                         v=dict(t=6, w=2),&#10;                         w=dict(t=3),&#10;                         t=dict())&#10;&#10;    graph_negative_cycle = dict(s=dict(v=10),&#10;                         v=dict(u=-4),&#10;                         u=dict(w=3),&#10;                         w=dict(x=-5),&#10;                         x=dict(v=4))&#10;    # @formatter:on&#10;&#10;    input_ = graph_negative_cycle&#10;&#10;    result = belmanFord(input_, 's')&#10;    print(&quot;MAIN belmanFord: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;main_belmanFord()" description="O=V *E   работает с отрицательными ребрами и показывает вершины цикла если он есть" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected FloydWarshall" value="##############################################################################################################################################################&#10;################# floydWarshal #####################################################################################################################################&#10;##############################################################################################################################################################&#10;def printMatrix(list_of_lists):&#10;    # печать матрицы&#10;    for y in list_of_lists:&#10;        for x in y:&#10;            print(x, end=&quot;\t&quot;)&#10;        print(&quot;\n&quot;)&#10;&#10;def is_negative_cycle(matrix):&#10;    for i in range(len(matrix)):&#10;        if matrix[i][i]&lt;0:&#10;            return True&#10;    return False&#10;    &#10;    &#10;def floydWarshal(graph):&#10;    &quot;&quot;&quot; floydWarshal return result&quot;&quot;&quot;&#10;    l = list(range(len(graph)))&#10;&#10;    result = [[inf for _ in l] for _ in l]&#10;    parents = [[None for _ in l] for _ in l]&#10;&#10;    # будем обращаться к вершинам для простоты по индексам&#10;    t = {v:idx for idx, v in enumerate(graph)}  # translation_table&#10;&#10;    # инициализируем нулевыми стоимостями&#10;    for i in l:&#10;        result[i][i] = 0&#10;&#10;    # из списка смежности получим матрицу смежности&#10;    for i, edges in graph.items():&#10;        for j, cost in edges.items():&#10;            result[t[i]][t[j]] = cost&#10;            parents[t[i]][t[j]] = i&#10;&#10;    for x in l:&#10;        for u in l:&#10;            for v in l:&#10;                if result[u][v] &gt; (best := result[u][x] + result[x][v]):&#10;                    result[u][v] = best&#10;                    parents[u][v] = parents[x][v]&#10;&#10;    return result, parents&#10;&#10;&#10;def main_floydWarshal():&#10;    #@formatter:off&#10;    graph_weighed = dict(a=dict(b=3, c=8),&#10;                         b=dict(d=1),&#10;                         c=dict(b=4),&#10;                         d=dict(a=2,c=-5))&#10;&#10;    graph_negative_cycle = dict(s=dict(v=10),&#10;                         v=dict(u=-4),&#10;                         u=dict(w=3),&#10;                         w=dict(x=-5),&#10;                         x=dict(v=4))&#10;    # @formatter:on&#10;&#10;    input_ = graph_weighed&#10;    result1,result2 = floydWarshal(input_)&#10;    printMatrix(result1)&#10;    printMatrix(result2)&#10;    print (is_negative_cycle(result1))&#10;&#10;&#10;main_floydWarshal()" description="O= V^3  находит расстояния между всеми вершинами" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function TSP dynamic version" value="##############################################################################################################################################################&#10;################# tsp #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;def tsp_file(filename):&#10;    result, cnt = [], 0&#10;    skip_first = True&#10;    for line in open(filename):&#10;        str = line.strip()&#10;        if not str: continue&#10;&#10;        if skip_first:&#10;            skip_first = False&#10;            cnt = int(str)&#10;            continue&#10;&#10;        w_, l_ = str.strip().split(&quot; &quot;)&#10;        w, l = float(w_.strip()), float(l_.strip())&#10;        assert isinstance(w, float), f&quot;NUM1={w}&quot;&#10;        assert isinstance(l, float), f&quot;NUM2={l}&quot;&#10;        result.append((w, l))&#10;    print(&quot;Integers readed:&quot;, len(result))&#10;    return result, cnt&#10;&#10;&#10;def file_to_graph(arr, n):&#10;    result = {}&#10;    for a, b in combinations(range(1, n + 1), 2):&#10;        x1, y1 = arr[a-1][0], arr[a-1][1]&#10;        x2, y2 = arr[b-1][0], arr[b-1][1]&#10;        result[(a, b)] = int( ((x1 - x2) ** 2 + (y1 - y2) ** 2)**0.5 )&#10;    return result&#10;&#10;&#10;def tsp1(graph, n):&#10;    &quot;&quot;&quot; brute forse &quot;&quot;&quot;&#10;    result_path, result_len = [], inf&#10;&#10;    for i in permutations(range(1, n + 1), n):&#10;        variant_len = 0&#10;        for j in range(n - 1):&#10;            a, b = i[j], i[j + 1]&#10;            variant_len += (graph.get((a, b)) or graph.get((b, a)))  # для получения вершины нужны дополнительынй скобки тк get многопараметрический&#10;&#10;        variant_len += (graph.get((i[0], i[n - 1])) or graph.get((i[n - 1], i[0])))  # замкнем путь&#10;        if result_len &gt; variant_len:&#10;            result_len = variant_len&#10;            result_path = i  # print(i, variant_len)&#10;&#10;    return result_len, result_path&#10;&#10;&#10;def tsp2(graph, n):&#10;    &quot;&quot;&quot; dynamic algo &quot;&quot;&quot;&#10;&#10;    # все подмножества элементов&#10;    subsets_raw = []&#10;    for i in range(1, n + 1):&#10;        subsets_raw += combinations(range(1, n + 1), i)&#10;&#10;    # только те которые содержат 1&#10;    subsets = [set(i) for i in subsets_raw if 1 in i]&#10;&#10;    # init&#10;    result = [[inf for _ in range(n + 1)] for _ in range(len(subsets))]  # y axes started from 1 for usability&#10;    result[0][0] = 0&#10;    result[0][1] = 0&#10;&#10;    weight = lambda x, y:(graph.get((x, y)) or graph.get((y, x)))&#10;&#10;    for m in range(2, n + 1):&#10;        for s_idx, s in [(idx, i) for idx, i in enumerate(subsets) if len(i) == m]:&#10;            for j in s:&#10;                if j == 1: continue  # result[]&#10;                result[s_idx][j] = min([result[subsets.index(s - {j})][k] + weight(k, j) for k in s if k != j])&#10;        print(&quot;progress:&quot;, m)&#10;&#10;    outcome = min([result[subsets.index(set(range(1, n + 1)))][j] + weight(1, j) for j in range(2, n + 1)])&#10;    return result, outcome&#10;&#10;&#10;def main_tsp():&#10;    data1 = {&#10;        (1, 2):2,&#10;        (2, 3):5,&#10;        (3, 4):6,&#10;        (4, 1):1,&#10;        (1, 3):4,&#10;        (2, 4):3}&#10;&#10;    arr, cnt = tsp_file(r'tsp.txt')&#10;    data2=file_to_graph(arr, cnt)&#10;    print(len(data2))&#10;&#10;    result, outc = tsp2(data1, 4)&#10;    print(&quot;MAIN tsp: &quot;, outc)  # printMatrix(result)&#10;&#10;&#10;main_tsp()" description="traveling salesman problem O ( n^2 * 2^n )" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function knapsack DYNAMIC" value="def rukzak_file(filename):&#10;    counter = itertools.count()  # unique sequence count&#10;    result_capacity = 0&#10;    result = {}&#10;    skip_first = True&#10;    for line in open(filename):&#10;        str_ = line.strip()&#10;        if not str_: continue&#10;&#10;        if skip_first:&#10;            skip_first = False&#10;            w_, l_ = str_.strip().split(&quot; &quot;)&#10;            w, l = int(w_.strip()), int(l_.strip())&#10;            result_capacity = w&#10;            continue&#10;        w_, l_ = str_.strip().split(&quot; &quot;)&#10;        w, l = int(w_.strip()), int(l_.strip())&#10;        assert isinstance(w, int), f&quot;NUM1={w}&quot;&#10;        assert isinstance(l, int), f&quot;NUM2={l}&quot;&#10;        idx = next(counter)&#10;        result[str(idx)] = (l, w)&#10;&#10;    print(&quot;Integers readed:&quot;, len(result))&#10;    return result, result_capacity&#10;&#10;&#10;def rukzak1(vesi, bagpack_capasity):&#10;    # нумерация для простоты будет с 1&#10;    # это также поможет иметь правильный доступ к предыдущей ячейке при старте&#10;    table_weights = [[0 for _ in range(len(vesi) + 1)] for _ in range(bagpack_capasity + 1)]&#10;    table_vesi = [[[] for _ in range(len(vesi) + 1)] for _ in range(bagpack_capasity + 1)]&#10;    # print(table)&#10;&#10;    for yy, (thing, (weight, cost)) in enumerate(vesi.items()):&#10;        y = yy + 1&#10;        print(&quot;progress:&quot;, y)&#10;        for x in range(1, bagpack_capasity + 1):&#10;            if (empty_weight := x - weight) &gt;= 0 and (new_cost := cost + table_weights[empty_weight][y - 1]) &gt; table_weights[x][y - 1]:&#10;                table_weights[x][y] = new_cost&#10;                table_vesi[x][y] = table_vesi[empty_weight][y - 1] + [thing]&#10;            else:&#10;                table_weights[x][y] = table_weights[x][y - 1]  # просто берем предыдущую ячейку&#10;                table_vesi[x][y] = table_vesi[x][y - 1]&#10;&#10;    return table_weights[-1][-1], table_vesi[-1][-1]&#10;&#10;&#10;&#10;&#10;def rukzak_main():&#10;    # things = {&#10;    #     &quot;mafon&quot;:Thing(4, 3000),&#10;    #     &quot;notebook&quot;:Thing(3, 2000),&#10;    #     &quot;guitar&quot;:Thing(1, 1500)}&#10;    things1 = {&#10;        &quot;mafon&quot;:(4, 3000),&#10;        &quot;notebook&quot;:(3, 2000),&#10;        &quot;guitar&quot;:(1, 1500)}&#10;&#10;    things2 = {&#10;        &quot;mafon&quot;:(4, 3000),&#10;        &quot;notebook&quot;:(3, 2000),&#10;        &quot;guitar&quot;:(1, 1500),&#10;        &quot;iphone&quot;:(1, 2000)}&#10;&#10;    # things3, rukzak_capacity = rukzak_file(r'knapsack1.txt')&#10;    things3, rukzak_capacity = rukzak_file(r'knapsack_big.txt')&#10;&#10;    rukzak_capacity2 = rukzak_capacity // 100&#10;    things4 = {k:(v1 // 100, v2) for k, (v1, v2) in things3.items()}&#10;&#10;    # a1 = [i[0] for i in things4.values()]&#10;    # for i in sorted(a1):&#10;    #     print(i)&#10;&#10;    # return&#10;    # r1, r2 = rukzak1(things4, rukzak_capacity2)&#10;    r1 = rukzak2(things4, rukzak_capacity2)&#10;    print(&quot;ITOGO VESHI:&quot;, r1)  # 2493893  # 100 4248680" description="O(n*Capacity)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function Closest pair of points" value="def distance(points):&#10;    &quot;&quot;&quot; [(x,y), (x,y)] &quot;&quot;&quot;&#10;&#10;    assert isinstance(points, list)&#10;    if len(points) &lt; 2:&#10;        return inf&#10;&#10;    return (points[0][0] - points[1][0]) ** 2 + (points[0][1] - points[1][1]) ** 2&#10;&#10;&#10;def closest_pair_splitted(points, delta):&#10;    &quot;&quot;&quot; [(x,y), (x,y), (x,y), (x,y) ...] &quot;&quot;&quot;&#10;    assert points&#10;    assert isinstance(points, list)&#10;&#10;    if len(points) &lt; 2:&#10;        return []&#10;&#10;    m = points[len(points) // 2][0] # mediana X&#10;    pts = [p for p in points if m - delta &lt; p[0] &lt; m + delta] # только те точки которые попадают в вертикальную полосу от X&#10;&#10;    best_distance, best_pair, l = inf, [], len(pts)&#10;    for i in range(0, l - 1):&#10;        for j in range(1, min(7, l - i)):&#10;            p1, p2 = pts[i], pts[i + j]&#10;            if (d := distance([p1, p2])) &lt; best_distance:&#10;                best_distance = d&#10;                best_pair = [p1, p2]&#10;&#10;    return best_pair&#10;&#10;&#10;def closest_pair(points):&#10;    &quot;&quot;&quot; [(x,y), (x,y), (x,y), (x,y) ...] &quot;&quot;&quot;&#10;    assert points&#10;    assert isinstance(points, list)&#10;&#10;    if len(points) == 1:&#10;        return []&#10;&#10;    points.sort(key=lambda x:x[0])&#10;    left, right = split_lists_equally(points) # разделили точки по оси Х на две группы&#10;&#10;    pt1 = closest_pair(left)&#10;    pt2 = closest_pair(right)&#10;    delta = min(distance(pt1), distance(pt2))&#10;    pt3 = closest_pair_splitted(points, delta)&#10;&#10;    return min([pt1, pt2, pt3], key=distance)&#10;&#10;&#10;P = [(2, 3), (12, 30), (40, 50), (5, 1), (2, 10), (3, 4)]&#10;print(&quot;closest_pair&gt;&gt;&quot;, cp := closest_pair(P), distance(cp))&#10;" description="O = n*log n  из всех точек найти те которые ближе друг к другу" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graphic functions DRAW POINTS" value="import matplotlib.pyplot as plt&#10;from math import *&#10;&#10;P = [(2, 3), (12, 30), (40, 50), (5, 1), (2, 10), (3, 4)]&#10;&#10;# Draw point based on above x, y axis values.&#10;plt.scatter([x for x, y in P], [y for x, y in P], s=10)&#10;for i, (x,y) in enumerate(P):&#10;    plt.annotate(f&quot;{x},{y}&quot;, (P[i][0], P[i][1]))&#10;plt.show()" description="matplotlib" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function knapsack GREEDY recursive" value="def knapsack1(capacities, costs, max_capacity, num_of_things):&#10;    &quot;&quot;&quot;&#10;    simpliest solution&#10;&#10;    input - capacities of things, costs of things&#10;    return max cost of things in bag&#10;    &quot;&quot;&quot;&#10;    cache = {}&#10;&#10;    def bag(max_cap, n):&#10;        &quot;&quot;&quot; input: num_of_things_in_bag and bag_capacity&quot;&quot;&quot;&#10;&#10;        if seen := cache.get((max_cap, n)): return seen&#10;&#10;        i = n - 1  # index&#10;&#10;        if n &lt;= 0 or max_cap &lt;= 0:&#10;            result = 0&#10;        elif capacities[i] &gt; max_cap:&#10;            result = bag(max_cap, n - 1)&#10;        else:&#10;            result = max(bag(max_cap, n - 1), bag(max_cap - capacities[i], n - 1) + costs[i])&#10;&#10;        cache[(max_cap, n)] = result&#10;        return result&#10;&#10;    return bag(max_capacity, num_of_things)&#10;&#10;&#10;def main_knapsack():&#10;    things1 = {&#10;        &quot;mafon&quot;:(4, 3000),&#10;        &quot;notebook&quot;:(3, 2000),&#10;        &quot;guitar&quot;:(1, 1500)}&#10;&#10;    things2 = {&#10;        &quot;mafon&quot;:(4, 3000),&#10;        &quot;notebook&quot;:(3, 2000),&#10;        &quot;guitar&quot;:(1, 1500),&#10;        &quot;iphone&quot;:(1, 2000)}&#10;&#10;    things3 = {&#10;        &quot;mafon&quot;:(4, 3000)}&#10;&#10;    things3, rukzak_capacity = rukzak_file(r'knapsack_big.txt')&#10;&#10;    input_ = things2&#10;    caps = [k for _, (k, v) in input_.items()]&#10;    costs = [v for _, (k, v) in input_.items()]&#10;&#10;    result = knapsack1(caps, costs, 6, len(input_))&#10;    print(&quot;MAIN knapsack: &quot;, result)&#10;&#10;&#10;main_knapsack()" description="O ( n^2 * MaxCost )" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
</templateSet>