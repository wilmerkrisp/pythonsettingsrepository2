<templateSet group="_ALGO">
  <template name="formap WHILE POP (GOOD dict iterate and delete element)" value="while $d0$:&#10;    print ($d0$.popitem())&#10;$END$    " description="while dict: popitem()" toReformat="false" toShortenFQNames="true">
    <variable name="d0" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for WHILE POP + result" value="result  = []&#10;while $left$ :&#10;    fst=$left$[0]&#10;    lst=$left$[-1]&#10;    result[:0] = [$left$.pop()]  &#10;&#10;$END$    " description="while list: pop()" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for WHILE POPLEFT DEQUEUE" value="result  = []&#10;arr=deque($left$)&#10;while arr :&#10;    fst=arr[0]&#10;    lst=arr[-1]&#10;    result+= [arr.popleft()]  &#10;&#10;$END$&#10;  " description="while dequeue: popleft()" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="func FILE read 1val" value="def file_to_array(filename):&#10;    result = []&#10;    for line in open(filename):&#10;        str=line.strip()&#10;        if not str:&#10;            continue&#10;        num=int(str)&#10;        assert isinstance(num,int), f&quot;NUM={num}&quot;&#10;        result.append(num)&#10;    print(&quot;Integers readed:&quot;,len(result) )&#10;    return result&#10;&#10;&#10;ARR4 = file_to_array(r'C:\Users\trans\Downloads\IntegerArray.txt')&#10;print(&quot;ARR4&gt;&gt;&quot;,ARR4[:3])&#10;&#10;&#10;&#10; " description="for line in open(filename)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graphic functions DRAW" value="import matplotlib.pyplot as plt&#10;from math import *&#10;&#10;F1 = [x ** 0.5 for x in range(1, 100)]&#10;F2 = [2 ** (log(x)) for x in range(1, 100)]&#10;F3 = [x ** (5/3) for x in range(1, 100)]&#10;&#10;fig, ax = plt.subplots()&#10;ax.plot(F1,color='black')&#10;ax.plot(F2,color='red')&#10;ax.plot(F3)&#10;plt.show()" description="matplotlib" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for FOR LIST" value="for i in range(0,len($P$)):&#10;    print($P$[i])" description="for i in range(len)" toReformat="false" toShortenFQNames="true">
    <variable name="P" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graph  undirected DRAW" value="import networkx as nx&#10;import matplotlib.pyplot as plt&#10;&#10;def draw_graph():&#10;    G = nx.Graph()&#10;    G.add_node(&quot;A&quot;)&#10;    G.add_node(&quot;B&quot;)&#10;    G.add_node(&quot;C&quot;)&#10;    G.add_node(&quot;D&quot;)&#10;    G.add_node(&quot;E&quot;)&#10;    G.add_node(&quot;F&quot;)&#10;    G.add_node(&quot;G&quot;)&#10;    G.add_edge(&quot;A&quot;, &quot;B&quot;)&#10;    G.add_edge(&quot;B&quot;, &quot;C&quot;)&#10;    G.add_edge(&quot;C&quot;, &quot;E&quot;)&#10;    G.add_edge(&quot;C&quot;, &quot;F&quot;)&#10;    G.add_edge(&quot;D&quot;, &quot;E&quot;)&#10;    G.add_edge(&quot;F&quot;, &quot;G&quot;)&#10;    plt.figure(figsize=(8, 8))&#10;    nx.draw(G)&#10;&#10;draw_graph()" description="networkx" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="OLD function GRAPHundirected  SUPER BFS lambda version" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, work=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$ return processed verticies&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return []&#10;    if not work: work = lambda x, y:None&#10;    if not start_vertex: start_vertex = next(iter(graph))&#10;    if not processed: processed = set()&#10;&#10;    q = []&#10;&#10;    def process(vertex_from, vertex_to):&#10;        nonlocal q, processed&#10;        if vertex_to in processed: return&#10;        processed |= {vertex_to}&#10;        q[:0] = [vertex_to]&#10;        print(f&quot; bfs process {vertex_from}-{vertex_to}&quot;)&#10;        work(vertex_from, vertex_to)&#10;&#10;    print(&quot;start verticle not processed=&quot;, start_vertex)&#10;    process(start_vertex, start_vertex) # ! no edge when start&#10;    while q:&#10;        v = q.pop()&#10;        for e in graph[v]:&#10;            process(v, e)&#10;&#10;    return processed&#10;&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_,result)&#10;&#10;&#10;main_$bfs$()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graph  undirected DRAW with labels" value="import networkx as nx&#10;import matplotlib.pyplot as plt&#10;&#10;&#10;&#10;def draw_graph(graph, labels_=None):&#10;    &quot;&quot;&quot;graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&quot;&quot;&quot;&#10;    if not labels_: labels_ = {}&#10;&#10;    g = nx.DiGraph()&#10;&#10;    for v in graph:&#10;        g.add_node(v)&#10;        label_additional = labels_.get(v, &quot;&quot;);&#10;        labels_[v] = f&quot;{v}  *{label_additional}*&quot;&#10;        for e in graph[v]:&#10;            try:&#10;                g.add_edge(v, e, w=graph[v][e])&#10;            except TypeError as error:&#10;                g.add_edge(v, e)&#10;&#10;    pos = nx.planar_layout(g)&#10;    # pos = nx.spring_layout(g)&#10;    nx.draw_networkx_nodes(g, pos)&#10;&#10;    nx.draw_networkx_labels(g, pos, labels=labels_)&#10;    nx.draw_networkx_edge_labels(g, pos)&#10;    nx.draw_networkx_edges(g, pos, edge_color='r', arrows=True)&#10;    plt.show()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="OLD function GRAPHundirected  SUPER DFS lambda version" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, work=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$  return processed verticies &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return []&#10;&#10;    if not work: work = lambda x:None&#10;    if not start_vertex: start_vertex = next(iter(graph))&#10;    if not processed: processed = set()&#10;&#10;    q = []&#10;&#10;    def is_process(vertex):&#10;        nonlocal q, processed&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        return True&#10;&#10;    will_process = lambda vertex: q.append(vertex)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while q:&#10;        v = q.pop()&#10;        if not is_process(v):&#10;            continue&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;        work(v)&#10;&#10;    return processed&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_,result)&#10;&#10;&#10;main_$bfs$()" description="DFS depth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  topological sort Kahns" value="##############################################################################################################################################################&#10;################# topological sort #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;def topo_sort(graph):&#10;    &quot;&quot;&quot; topo_sort &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return [],set()&#10;&#10;    stack_, processed, inputs, result = [], set(), defaultdict(int), []&#10;&#10;    # find for all vertices num of inputs edges&#10;    for v in graph:&#10;        for e in graph[v]:&#10;            inputs[e] += 1&#10;&#10;    # for cycled graph, downgrade to 0&#10;    min_ = min(inputs.values())&#10;    inputs = {k:v - min_ for k, v in inputs.items()}&#10;&#10;&#10;    stack_ += [v for v, i in inputs.items() if i &lt;= 0]&#10;    print(&quot;start form=&quot;, stack_)&#10;    while stack_:&#10;        v = stack_.pop()&#10;        for e in graph[v]:&#10;            inputs[e] -= 1&#10;            if not inputs[e]:&#10;                stack_ += [e]&#10;        print(f&quot;ts process v={v}&quot;)&#10;        result += [v]&#10;&#10;    return result,processed&#10;    &#10;" description="TS  algo/  ONLY FOR ACYCLIC" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="OLD function GRAPHundirected  shortest paths lambda version" value="def shortest_path2(graph):&#10;    &quot;&quot;&quot; shortest_path &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    lens = {v:inf for v in graph}&#10;    start_vertex, lens[start_vertex] = 1, 0&#10;    add_len = lambda x, y:lens.__setitem__(y, lens[x] + 1)&#10;    # debug_len = lambda y, x:print(&quot;debug&quot;, x, y)&#10;    bfs(graph, start_vertex, add_len)&#10;&#10;    return lens&#10;&#10; " description="lens of verticies" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="OLD function GRAPHundirected  weak connected conponents lambda version" value="def undirected_connected_components2(graph):&#10;    &quot;&quot;&quot; undirected_connected_components &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    processed, connectings, counter = set(), {}, 0&#10;    set_counter = lambda x, y:connectings.__setitem__(y, counter)&#10;&#10;    for w in graph:&#10;        if w in processed: continue&#10;        counter += 1&#10;        processed |= bfs(graph, w, set_counter, processed)&#10;        print(&quot;PROCESSED=&quot;, processed)&#10;&#10;    return connectings&#10;&#10; " description="lens of verticies" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="OLD function GRAPHdirected connected conponents STRONG lambda version" value="def revers(graph):&#10;    &quot;&quot;&quot; revers &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    result = {v:[] for v in graph}&#10;    for v in graph:&#10;        for e in graph[v]:&#10;            result[e] += [v]&#10;&#10;    return result&#10;&#10;&#10;def kesaray(graph):&#10;    &quot;&quot;&quot; kesaray  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    # first stage of keserayo algo&#10;    reversed_ = revers(graph)&#10;    sorted_ = topo_sort(reversed_)&#10;    print(&quot;GRAPH&quot;, graph)&#10;&#10;    processed, result, counter, f = set(), {}, 0, lambda v:result.setdefault(v, counter)&#10;&#10;    for w in sorted_:&#10;        if w in processed: continue&#10;        counter += 1&#10;        processed |= dfs(graph, w, f, processed)&#10;        print(f&quot;&gt;&gt; processed={processed} result={result}&quot;)&#10;&#10;    return result&#10;&#10;&#10;# ????&#10;def metagraph(table):&#10;    res = {v:[] for v in set(table.values())}&#10;    for v, w in table.items():&#10;        res[w] += [v]&#10;    return res" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="OLD function GRAPHundirected  SUPER DFS v2" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$ return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    stack_, processed, start_vertex, result = [], processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    def is_process(vertex):&#10;        nonlocal processed&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        return True&#10;&#10;    will_process = lambda vertex:stack_.append(vertex)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while stack_:&#10;        v = stack_.pop()&#10;        if not is_process(v): continue&#10;        if v not in graph: print(&quot;!! vertix not exists in first column of graph table:&quot;, v); continue&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;        result += [v]&#10;&#10;    return result, processed&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;main_$bfs$()" description="DFS depth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER BFS 3bad" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, processed=None, both_vertex=False):&#10;    &quot;&quot;&quot; $bfs$ return ordered(vertix_from,vertix_to) and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return [], []&#10;&#10;    queue_, start_vertex, processed, result = [], start_vertex or next(iter(graph)), processed or set(), []&#10;&#10;    def process(vertex_from, vertex_to):&#10;        nonlocal queue_, processed, result&#10;        if vertex_to in processed: return&#10;        processed |= {vertex_to}&#10;        queue_[:0] = [vertex_to]&#10;        print(f&quot; bfs process {vertex_from}-{vertex_to}&quot;)&#10;        if both_vertex:&#10;            result += [(vertex_from, vertex_to)]&#10;        else:&#10;            result += [vertex_to]    &#10;&#10;    print(&quot;start verticle not processed=&quot;, start_vertex)&#10;    process(start_vertex, start_vertex)  # ! no edge when start&#10;    while queue_:&#10;        v = queue_.pop()&#10;        for e in graph[v]:&#10;            process(v, e)&#10;&#10;    return result, processed&#10;&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;main_$bfs$()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  shortest paths" value="def shortest_path2(graph):&#10;    &quot;&quot;&quot; shortest_path &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    lens = defaultdict(lambda:inf)&#10;    start_vertex, lens[start_vertex] = 1, 0&#10;&#10;    traversed, _ = bfs(graph, start_vertex)&#10;    for v, e in traversed: lens[e] = lens[v] + 1&#10;&#10;    return lens&#10;&#10; " description="lens of verticies" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected connected conponents UNDIRECTED" value="def undirected_connected_components2(graph):&#10;    &quot;&quot;&quot; undirected_connected_components &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    processed, ccomponents, counter = set(), {}, 0&#10;&#10;    for w in graph:&#10;        if w in processed: continue&#10;        counter += 1&#10;        traversed, processed =dfs(graph, w, processed)&#10;        for v in traversed: ccomponents[v]=counter&#10;&#10;    return ccomponents&#10;&#10; " description="lens of verticies" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected  strong  connected conponents" value="def revers(graph):&#10;    &quot;&quot;&quot; direction of all edges reversed  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    result = defaultdict(list)&#10;    for v in graph:&#10;        for e in graph[v]:&#10;            result[e] += [v]&#10;&#10;    return result&#10;&#10;&#10;def metagraph(table):&#10;    &quot;&quot;&quot; swap keys and values &quot;&quot;&quot;&#10;    res = defaultdict(list)&#10;    for v, w in table.items():&#10;        res[w] += [v]&#10;    return res&#10;    &#10;&#10;def kesaray(graph):&#10;    &quot;&quot;&quot; kesaray  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    # first stage of keserayo algo&#10;    reversed_ = revers(graph)&#10;    topo_sorted = topo_sort(reversed_)&#10;    print(&quot;GRAPH&quot;, graph)&#10;&#10;    # dfs/bfs - second stage of kesarayo algo&#10;    processed, result, counter = set(), {}, 0&#10;    for w in topo_sorted:&#10;        if w in processed: continue&#10;        counter += 1&#10;        traversed, processed = dfs(graph, w, processed)&#10;        for v in traversed: result.setdefault(v, counter)&#10;&#10;    return result&#10;&#10;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  topological sort SUPER  recursion classic" value="##############################################################################################################################################################&#10;################# topological sort #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;def topo_sort3(graph, processed=None):&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], set()&#10;&#10;    processed, result, counter = processed or set(), {}, l&#10;&#10;    def process(vertex):&#10;        nonlocal processed&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        return True&#10;&#10;    def dfss(vertex):&#10;        nonlocal counter&#10;        process(vertex)&#10;        for e in graph[vertex]:&#10;            if e not in processed:&#10;                dfss(e)&#10;        print(f&quot; dfs3processed={vertex}={counter}&quot;)&#10;        result[vertex] = counter&#10;        counter -= 1&#10;&#10;    for w in graph:&#10;        if w in processed: continue&#10;        dfss(w)&#10;&#10;    result2 = [k for k, v in sorted(result.items(), key=lambda e:e[1])]&#10;    return result2, processed&#10;    &#10;" description="TS  algo/ DFS recursion /  FOR CYCLIC" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected topological sort STACK 2" value="def topo_sort2(graph, processed=None):&#10;    &quot;&quot;&quot; dfs return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], set()&#10;&#10;    stack_, processed, result, counter = [], processed or set(), {}, l&#10;&#10;    def process(vertex):&#10;        nonlocal processed, stack_&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        stack_ += [vertex]&#10;        return True&#10;&#10;    for w in graph:&#10;        if not process(w): continue&#10;&#10;        while stack_:&#10;            v = stack_.pop()&#10;&#10;            if v &gt;= 0:&#10;                stack_ += [-v - 1] # TRICK: add for post processing later&#10;                for e in graph[v]:&#10;                    process(e) &#10;            else:&#10;                vertex = -v - 1  # initial vertex when pushed&#10;                result[vertex] = counter&#10;                counter -= 1&#10;&#10;    result2 = [k for k, v in sorted(result.items(), key=lambda e:e[1])]&#10;    return result2, processed&#10;    &#10;" description="TS  algo/ double push /  FOR CYCLIC" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected topological sort STACK  1" value="def topo_sort2(graph, processed=None):&#10;    &quot;&quot;&quot; dfs return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], set()&#10;&#10;    stack_, processed, result, counter = [], processed or set(), {}, l&#10;    stack_2 = []&#10;&#10;    def is_process(vertex):&#10;        nonlocal processed&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        print(&quot;is_process:&quot;, vertex, stack_)&#10;        return True&#10;&#10;    def will_process(vertex):&#10;        nonlocal stack_&#10;        stack_.append(vertex)&#10;        print(&quot;will_process:&quot;, vertex, stack_)&#10;&#10;    for w in graph:&#10;        if w in processed: continue&#10;&#10;        print(&quot;start from&quot;, w)&#10;        will_process(w)&#10;        while stack_2 + stack_:&#10;            v = stack_.pop() if stack_ else stack_2.pop()&#10;            if not is_process(v): continue&#10;&#10;            if v &gt;= 0:&#10;                stack_2 += [-v - 1]  # TRICK: add for post processing later&#10;&#10;                for e in graph[v]:&#10;                    will_process(e)&#10;            else:&#10;                vertex = -v - 1  # initial vertex when pushed&#10;                print(f&quot;RESULT {vertex}={counter}&quot;)&#10;                result[vertex] = counter&#10;                counter -= 1&#10;&#10;    result2 = [k for k, v in sorted(result.items(), key=lambda e:e[1])]&#10;    return result2, processed&#10;    &#10;" description="TS  algo/ double push /  FOR CYCLIC" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER DFS  1" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$ return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    stack_, processed, start_vertex, result = [], processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    def is_process():&#10;        nonlocal processed&#10;        vertex = stack_.pop()&#10;        if vertex in processed: return None&#10;        processed |= {vertex}&#10;        return vertex&#10;&#10;    will_process = lambda vertex:stack_.append(vertex)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while stack_:&#10;        if not (v := is_process()): continue&#10;        if v not in graph: print(&quot;!! vertix not exists in first column of graph table:&quot;, v); continue&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;        result += [v]&#10;&#10;    return result, processed&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;main_$bfs$()" description="DFS depth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected Dijkstra var2 base" value="def dijkstra(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; dijkstra return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    costs, parents, processed, start_vertex, result = {k:inf for k, v in graph.items()}, {}, processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    def process():&#10;        nonlocal processed&#10;        # // это обязательно так как если этого не сделать то обязательно найдется минимальный элемент даже если и обрабатывать нечего&#10;        if not graph.keys() - processed: return None&#10;        vertex, cost = min(costs.items(), key=lambda e:e[1] if e[0] not in processed else inf)&#10;        # //если находится только бесконечность то означает что идти больше некуда&#10;        if cost &gt;= inf: return None&#10;        processed |= {vertex}&#10;        return vertex&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    costs[start_vertex] = 0&#10;&#10;    while v := process():&#10;        for n, c in graph[v].items():&#10;            new_cost = costs[v] + c&#10;            if costs[n] &gt; new_cost:&#10;                costs[n] = new_cost&#10;                parents[n] = v&#10;        print(f&quot;dfs process v={v}&quot;)&#10;&#10;    p = {v:k for k, v in parents.items()}&#10;    next_vertex = start_vertex&#10;    result += start_vertex&#10;    while next_vertex := p.pop(next_vertex, None):&#10;        result += next_vertex&#10;&#10;    return result, processed&#10;&#10;&#10;def dijkstra_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;&#10;    input_ = graph_weighed&#10;    result = dijkstra(input_, 't')&#10;    print(&quot;MAIN bfs: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;dijkstra_main()" description="O=V*E" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="formap WHILE pop C-STYLE  PARENT_TABLE pop" value="result=[]    &#10;next_vertex = start_vertex&#10;result += start_vertex&#10;while next_vertex := $d0$.pop(next_vertex, None):&#10;    result += next_vertex    &#10;    &#10;$END$    " description="while next=pop(next):   # iterate over network" toReformat="false" toShortenFQNames="true">
    <variable name="d0" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="formap WHILE POP C-STYLE" value="while e:=$d0$.popitem() if $d0$ else None:&#10;    print (e)&#10;$END$&#10;" description="while popitem():" toReformat="false" toShortenFQNames="true">
    <variable name="d0" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for WHILE POP C-STYLE" value="while i:=$left$.pop() if $left$ else None:&#10;    print(i)&#10;    &#10;$END$    " description="while pop():" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for WHILE POP HEAP" value="while i := heappop($left$) if $left$ else None:&#10;    print(i)&#10;    &#10;$END$&#10;  " description="while heappop:" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="BAD function GRAPHdirected Dijkstra" value="##############################################################################################################################################################&#10;################# dijkstra #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def dijkstra(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; dijkstra return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    costs, parents, processed, start_vertex, result = {k:inf for k, v in graph.items()}, {}, processed or set(), start_vertex or next(iter(graph)), []&#10;    heap = []&#10;&#10;    def will_process(vertex, cost):&#10;        nonlocal processed&#10;        if vertex in processed: return&#10;        processed |= {vertex}&#10;        heappush(heap, (cost, vertex))&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    costs[start_vertex] = 0&#10;    heappush(heap, (0, start_vertex))&#10;    while v := heappop(heap) if heap else None:&#10;        vertex = v[1]&#10;        for n, c in graph[vertex].items():&#10;            new_cost = costs[vertex] + c&#10;            if costs[n] &gt; new_cost:&#10;                costs[n] = new_cost&#10;                parents[n] = vertex&#10;                will_process(n, new_cost)&#10;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;&#10;    print(costs, parents)&#10;    p = {v:k for k, v in parents.items()}&#10;    next_vertex = start_vertex&#10;    result += start_vertex&#10;    while next_vertex := p.pop(next_vertex, None):&#10;        result += next_vertex&#10;&#10;    return result, processed&#10;&#10;&#10;def dijkstra_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;&#10;    input_ = graph_weighed&#10;&#10;    print(&quot;MAIN bfs1: &quot;, dijkstra(input_, 's'))&#10;    print(&quot;MAIN bfs2: &quot;, dijkstra(input_, 't'))&#10;    draw_graph(input_)&#10;&#10;&#10;dijkstra_main()" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected Dijkstra  var2 heap" value="def dijkstra(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; dijkstra return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    costs, parents, processed, start_vertex, result = {k:inf for k, v in graph.items()}, {}, processed or set(), start_vertex or next(iter(graph)), []&#10;    costs[start_vertex] = 0&#10;    heap = Heap([[v, k] for k, v in costs.items()])&#10;&#10;    print(&quot;heap:&quot;, heap)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    while v := heap.pop():&#10;        processed |= {v}&#10;        for n, c in graph[v].items():&#10;            if n not in heap.entry_finder: continue # based on hash-set O=1&#10;            new_cost = costs[v] + c&#10;            if costs[n] &gt; new_cost:&#10;                costs[n] = new_cost&#10;                parents[n] = v&#10;                heap.push(new_cost, n)&#10;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;&#10;    p = {v:k for k, v in parents.items()}&#10;    next_vertex = start_vertex&#10;    result += [start_vertex]&#10;    while next_vertex := p.pop(next_vertex, None):&#10;        result += [next_vertex]&#10;&#10;    return result, processed&#10;&#10;&#10;def dijkstra_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;&#10;    input_ = graph_weighed&#10;&#10;    print(&quot;MAIN bfs1: &quot;, dijkstra(input_, 's'))&#10;    print(&quot;MAIN bfs2: &quot;, dijkstra(input_, 't'))&#10;    draw_graph(input_)&#10;&#10;&#10;dijkstra_main()" description="O=V+E*log V с ненужным массивом processed" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected Dijkstra var1 base" value="def dijkstra1(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; dijkstra return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    costs, parents, processed, start_vertex, result = {k:inf for k, v in graph.items()}, {}, processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    def process():&#10;        nonlocal processed&#10;        itog = {v:e for v, e in costs.items() if v not in processed}&#10;        if not len(itog): return None&#10;        vertex, cost = min(itog.items(), key=lambda e:e[1])&#10;        processed |= {vertex}&#10;        return vertex&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    costs[start_vertex] = 0&#10;&#10;    while v := process():&#10;        for n, c in graph[v].items():&#10;            new_cost = costs[v] + c&#10;            if costs[n] &gt; new_cost:&#10;                costs[n] = new_cost&#10;                parents[n] = v&#10;        print(f&quot;dfs process v={v}&quot;)&#10;&#10;    p = {v:k for k, v in parents.items()}&#10;    next_vertex = start_vertex&#10;    result += start_vertex&#10;    while next_vertex := p.pop(next_vertex, None):&#10;        result += next_vertex&#10;&#10;    return result, processed&#10;&#10;&#10;def dijkstra1_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;&#10;    input_ = graph_weighed&#10;    result = dijkstra1(input_, 't')&#10;    print(&quot;MAIN bfs: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;dijkstra1_main()&#10;" description="O=V*E" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER BFS 2" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$ return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    stack_, processed, start_vertex, result = [], processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    def is_process():&#10;        nonlocal processed&#10;        vertex = stack_.pop()&#10;        if vertex in processed: return None&#10;        processed |= {vertex}&#10;        return vertex&#10;&#10;    will_process = lambda vertex:stack_.insert(1,vertex)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while stack_:&#10;        if not (v := is_process()): continue&#10;        if v not in graph: print(&quot;!! vertix not exists in first column of graph table:&quot;, v); continue&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;        result += [v]&#10;&#10;    return result, processed&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;main_$bfs$()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER BFS 1" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$ return ordered and processed vertices&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], []&#10;&#10;    stack_, processed, start_vertex, result = [], processed or set(), start_vertex or next(iter(graph)), []&#10;&#10;    will_process = lambda vertex:stack_.append(vertex)&#10;    #will_process = lambda vertex:stack_.insert(0, vertex)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while v := (stack_.pop() if stack_ else None):&#10;        if v in processed: continue&#10;        processed |= {v}&#10;&#10;        for e in graph[v]:&#10;            will_process(e)  # print(f&quot;    v={v} e={e} arr={q}&quot;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;        result += [v]&#10;&#10;    return result, processed&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_)&#10;&#10;&#10;main_$bfs$()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="func FILE read 2val" value="def $file_to_array$(filename):&#10;    result = []&#10;    skip_first=True&#10;    for line in open(filename):&#10;        str = line.strip()&#10;        if not str: continue&#10;&#10;        if skip_first: skip_first=False; continue&#10;        w_, l_ = str.strip().split(&quot; &quot;)&#10;        w, l = int(w_.strip()), int(l_.strip())&#10;        assert isinstance(w, int), f&quot;NUM1={w}&quot;&#10;        assert isinstance(l, int), f&quot;NUM2={l}&quot;&#10;        result.append((w,l))&#10;    print(&quot;Integers readed:&quot;, len(result))&#10;    return result&#10;&#10;&#10;arr = $file_to_array$(r'C:\Users\trans\Downloads\IntegerArray.txt')&#10;print(&quot;ARR4&gt;&gt;&quot;,arr)" description="for line in open(filename)" toReformat="false" toShortenFQNames="true">
    <variable name="file_to_array" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GREEDY schedule 2 queue" value="def file_to_array1(filename):&#10;    result = []&#10;    skip_first = True&#10;    for line in open(filename):&#10;        str = line.strip()&#10;        if not str: continue&#10;&#10;        if skip_first: skip_first = False; continue&#10;        w_, l_ = str.strip().split(&quot; &quot;)&#10;        w, l = int(w_.strip()), int(l_.strip())&#10;        assert isinstance(w, int), f&quot;NUM1={w}&quot;&#10;        assert isinstance(l, int), f&quot;NUM2={l}&quot;&#10;        result.append((w, l))&#10;    print(&quot;Integers readed:&quot;, len(result))&#10;    return result&#10;&#10;&#10;def greedy_schedule(tasks):&#10;    list_ = [(round(w / l, 2), w, l) for w, l in tasks]&#10;    list_.sort(key=lambda e:e[0])  # sorted from min-&gt;max than pop() from max&#10;    #print(&quot;sorted:&quot;, list_)&#10;    sum = 0&#10;    term = 0&#10;    while e := list_.pop() if list_ else None:&#10;        term += e[2]&#10;        sum += e[1] * term&#10;        #print(f&quot;&gt;&gt; {term} {sum}&quot;)&#10;    return sum&#10;&#10;def greedy_main():&#10;    arr = file_to_array1(r'problem13.4.txt')&#10;    #arr = file_to_array1(r'problem.txt')&#10;    #print(arr)&#10;    print(&quot;ARR4&gt;&gt;&quot;, greedy_schedule(arr))&#10;&#10;&#10;greedy_main()&#10;&#10;&#10;" description="minimize weightned sum problem" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GREEDY schedule 1 for_list" value="def file_to_array1(filename):&#10;    result = []&#10;    skip_first = True&#10;    for line in open(filename):&#10;        str = line.strip()&#10;        if not str: continue&#10;&#10;        if skip_first: skip_first = False; continue&#10;        w_, l_ = str.strip().split(&quot; &quot;)&#10;        w, l = int(w_.strip()), int(l_.strip())&#10;        assert isinstance(w, int), f&quot;NUM1={w}&quot;&#10;        assert isinstance(l, int), f&quot;NUM2={l}&quot;&#10;        result.append((w, l))&#10;    print(&quot;Integers readed:&quot;, len(result))&#10;    return result&#10;&#10;&#10;def greedy_schedule(tasks):&#10;    list_ = [(round(w / l, 2), w, l) for w, l in tasks]&#10;    list_.sort(key=lambda e:e[0], reverse=True) # from max to min&#10;    # print(&quot;sorted:&quot;, list_)&#10;    sum = 0&#10;    term = 0&#10;    for _, w, l in list_:&#10;        term += l&#10;        sum += w * term  &#10;    # print(f&quot;&gt;&gt; {term} {sum}&quot;)&#10;    return sum&#10;&#10;def greedy_main():&#10;    arr = file_to_array1(r'problem13.4.txt')&#10;    #arr = file_to_array1(r'problem.txt')&#10;    #print(arr)&#10;    print(&quot;ARR4&gt;&gt;&quot;, greedy_schedule(arr))&#10;&#10;&#10;greedy_main()&#10;&#10;&#10;" description="minimize weightned sum problem" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHdirected Dijkstra  var1 heap" value="def dijkstra(graph, start_vertex=None ):&#10;    &quot;&quot;&quot; dijkstra return ordered  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return []&#10;&#10;    costs, parents, start_vertex, result = {k:inf for k, v in graph.items()}, {}, start_vertex or next(iter(graph)), []&#10;    costs[start_vertex] = 0&#10;    heap = Heap([[v, k] for k, v in costs.items()])&#10;&#10;    print(&quot;heap:&quot;, heap)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    while v := heap.pop():&#10;        for n, c in graph[v].items():&#10;            if n not in heap.entry_finder: continue  # find-operation based on hash-set O=1&#10;            new_cost = costs[v] + c&#10;            if costs[n] &gt; new_cost:&#10;                costs[n] = new_cost&#10;                parents[n] = v&#10;                heap.push(new_cost, n)&#10;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;&#10;    p = {v:k for k, v in parents.items()}&#10;    next_vertex = start_vertex&#10;    result += [start_vertex]&#10;    while next_vertex := p.pop(next_vertex, None):&#10;        result += [next_vertex]&#10;&#10;    return result&#10;&#10;&#10;def dijkstra_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;&#10;    input_ = graph_weighed&#10;&#10;    print(&quot;MAIN bfs1: &quot;, dijkstra(input_, 's'))&#10;    print(&quot;MAIN bfs2: &quot;, dijkstra(input_, 't'))&#10;    draw_graph(input_)&#10;&#10;&#10;dijkstra_main()" description="O=V+E*log V" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  MST1 dijkstra" value="def mst1_prima(graph, start_vertex=None):&#10;    &quot;&quot;&quot; mst based on dijkstra return  MST-graph  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return []&#10;&#10;&#10;    costs, parents, start_vertex, result = {k:inf for k, v in graph.items()}, {}, start_vertex or next(iter(graph)), []&#10;    costs[start_vertex] = 0&#10;    heap = Heap([[v, k] for k, v in costs.items()])&#10;&#10;    print(&quot;heap:&quot;, heap)&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    while v := heap.pop():&#10;        for n, c in graph[v].items():&#10;            if n not in heap.entry_finder: continue&#10;            new_cost = c # единственное отличие от алгоритма Дейкстры&#10;            if new_cost &lt; costs[n]:&#10;                costs[n] = new_cost&#10;                parents[n] = v&#10;                heap.push(new_cost, n)&#10;&#10;        print(f&quot;dfs process v={v}&quot;)&#10;&#10;&#10;    return parents&#10;&#10;&#10;def mst1_prima_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;    graph_mst = dict(a=dict(b=1, c=4, d=3), b=dict(a=1, d=2), c=dict(a=4, d=5), d=dict(b=2, c=5, a=3))&#10;&#10;    input_ = graph_mst&#10;&#10;    print(&quot;MAIN bfs1: &quot;, mst1_prima(input_, 'a'))&#10;    print(&quot;MAIN bfs2: &quot;, mst1_prima(input_, 'd'))&#10;    draw_graph(input_)&#10;&#10;&#10;mst1_prima_main()" description="Prima's algo (Dijkstra) minimum spanning tree O=V+E*log V" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="formap WHILE pop C-STYLE  PARENT_TABLE iter" value="next_vertex = start_vertex&#10;while next_parent := $d0$.get(next_vertex):  # get=None if absent&#10;    if next_vertex == next_parent: return next_parent&#10;    next_vertex = next_parent&#10;         &#10;$END$    " description="while next=get(next):   # iterate over network" toReformat="false" toShortenFQNames="true">
    <variable name="d0" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  MST2 union-find" value="@dataclass&#10;class Parent:&#10;    parent: Any&#10;    size: int&#10;&#10;&#10;class UnionFind():&#10;    &quot;&quot;&quot; structure for Kraskal's MST graphs&#10;&#10;        obj1 = UnionFind([1, 2, 3, 4])&#10;        p1 = obj1.find(1)&#10;        p2 = obj1.find(2)&#10;        print(obj1)&#10;        obj1.union(p1, p2)&#10;        print(obj1)&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, list_):&#10;        if not list_: raise ValueError(&quot;Constructor's argument must not be empty.&quot;)&#10;        assert isinstance(list_, list)&#10;&#10;        self.__table = {o:Parent(o, 1) for o in list_}&#10;&#10;    def find(self, object_):&#10;        &quot;&quot;&quot; find some object in sets and return set (Parent object)&quot;&quot;&quot;&#10;        if object_ not in self.__table: return None&#10;&#10;        next_vertex = object_&#10;        while next_parent := self.__table.get(next_vertex):&#10;            if next_vertex == next_parent.parent: return next_parent&#10;            next_vertex = next_parent.parent&#10;&#10;    def union(self, parent1, parent2):&#10;        &quot;&quot;&quot; union two sets(Parent objects) into one set &quot;&quot;&quot;&#10;        if not parent1 or not parent2: raise ValueError(&quot;arguments must not be empty.&quot;)&#10;        assert isinstance(parent1, Parent)&#10;        assert isinstance(parent2, Parent)&#10;&#10;        if parent1.size &lt;= parent2.size:&#10;            parent2.parent = parent1.parent&#10;            parent1.size += parent2.size&#10;        else:&#10;            parent1.parent = parent2.parent&#10;            parent2.size += parent1.size&#10;&#10;    def __repr__(self):&#10;        return f&quot;{self.__table}&quot;&#10;&#9;&#9;&#10;&#10;def mst_kraskal(graph, start_vertex=None):&#10;    &quot;&quot;&quot; mst based on dijkstra return  MST-graph  &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return [], 0&#10;&#10;    costs, parents, start_vertex, result = [(v1, v2, cost) for v1, dict1 in graph.items() for v2, cost in dict1.items()], {}, start_vertex or next(iter(graph)), []&#10;    costs.sort(key=lambda e:e[2])&#10;&#10;    sets = UnionFind(list(graph))&#10;    for e1, e2, cost in costs:&#10;        if (s1 := sets.find(e1)) is not (s2 := sets.find(e2)):&#10;            sets.union(s1, s2)&#10;            result += [(e1, e2, cost)]&#10;&#10;    sum_ = sum(v for _, _, v in result)&#10;    return result, sum_&#10;&#10;&#10;def mst_kraskal_main():&#10;    graph_directed = dict(a=['b', 'c'], b=['c', 'd'], c=['d'], d=[])&#10;    graph_weighed = dict(s=dict(v=1, w=4), v=dict(t=6, w=2), w=dict(t=3), t=dict())&#10;    graph_mst = dict(a=dict(b=1, c=4, d=3), b=dict(a=1, d=2), c=dict(a=4, d=5), d=dict(b=2, c=5, a=3))&#10;&#10;    # input_ = mst_grap_load(r'edges.txt')&#10;    input_ = graph_mst&#10;&#10;    print(&quot;MAIN bfs1: &quot;, mst_kraskal(input_))  # -3612829&#10;    # print(&quot;MAIN bfs2: &quot;, mst1_prima(input_, 'd'))&#10;    draw_graph(input_)&#10;&#10;&#10;mst_kraskal_main()&#10;&#9;" description="Kraskal's algo (UnionFind) minimum spanning tree O=V+E*log V" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
</templateSet>