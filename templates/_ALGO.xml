<templateSet group="_ALGO">
  <template name="for WHILE  POP (GOOD dict iterate and delete element)" value="while $d0$:&#10;    print ($d0$.popitem())&#10;$END$    " description="while POPitem" toReformat="false" toShortenFQNames="true">
    <variable name="d0" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for WHILE POP + result" value="result  = []&#10;while $left$ :&#10;    fst=$left$[0]&#10;    lst=$left$[-1]&#10;    result[:0] = [$left$.pop()]  &#10;&#10;$END$    " description="while POPitem" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for WHILE POPLEFT + result" value="result  = []&#10;arr=deque($left$)&#10;while  :&#10;    fst=arr[0]&#10;    lst=arr[-1]&#10;    result+= [arr.popleft()]  &#10;&#10;$END$&#10;  " description="while POPLEFTitem" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="func readfile" value="def file_to_array(filename):&#10;    result = []&#10;    for line in open(filename):&#10;        str=line.strip()&#10;        if not str:&#10;            continue&#10;        num=int(str)&#10;        assert isinstance(num,int), f&quot;NUM={num}&quot;&#10;        result.append(num)&#10;    print(&quot;Integers readed:&quot;,len(result) )&#10;    return result&#10;&#10;&#10;ARR4 = file_to_array(r'C:\Users\trans\Downloads\IntegerArray.txt')&#10;print(&quot;ARR4&gt;&gt;&quot;,ARR4[:3])&#10;&#10;&#10;&#10;&#10;***&#10;def file_to_array(filename):&#10;    result = []&#10;    for line in open(filename):&#10;        result.append(line.strip())&#10;    return result&#10;&#10;&#10;ARR4 = file_to_array(r'C:\Users\trans\Downloads\IntegerArray.txt')&#10;***" description="for line in open(filename)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graphic functions DRAW" value="import matplotlib.pyplot as plt&#10;from math import *&#10;&#10;F1 = [x ** 0.5 for x in range(1, 100)]&#10;F2 = [2 ** (log(x)) for x in range(1, 100)]&#10;F3 = [x ** (5/3) for x in range(1, 100)]&#10;&#10;fig, ax = plt.subplots()&#10;ax.plot(F1,color='black')&#10;ax.plot(F2,color='red')&#10;ax.plot(F3)&#10;plt.show()" description="matplotlib" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="for FOR LIST" value="for i in range(0,len($P$)):&#10;    print($P$[i])" description="for i in range(len)" toReformat="false" toShortenFQNames="true">
    <variable name="P" expression="pyIterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graph  undirected DRAW" value="import networkx as nx&#10;import matplotlib.pyplot as plt&#10;&#10;def draw_graph():&#10;    G = nx.Graph()&#10;    G.add_node(&quot;A&quot;)&#10;    G.add_node(&quot;B&quot;)&#10;    G.add_node(&quot;C&quot;)&#10;    G.add_node(&quot;D&quot;)&#10;    G.add_node(&quot;E&quot;)&#10;    G.add_node(&quot;F&quot;)&#10;    G.add_node(&quot;G&quot;)&#10;    G.add_edge(&quot;A&quot;, &quot;B&quot;)&#10;    G.add_edge(&quot;B&quot;, &quot;C&quot;)&#10;    G.add_edge(&quot;C&quot;, &quot;E&quot;)&#10;    G.add_edge(&quot;C&quot;, &quot;F&quot;)&#10;    G.add_edge(&quot;D&quot;, &quot;E&quot;)&#10;    G.add_edge(&quot;F&quot;, &quot;G&quot;)&#10;    plt.figure(figsize=(8, 8))&#10;    nx.draw(G)&#10;&#10;draw_graph()" description="networkx" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER BFS" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, work=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$ return processed verticies&quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return []&#10;    if not work: work = lambda x, y:None&#10;    if not start_vertex: start_vertex = next(iter(graph))&#10;    if not processed: processed = set()&#10;&#10;    q = []&#10;&#10;    def process(vertex_from, vertex_to):&#10;        nonlocal q, processed&#10;        if vertex_to in processed: return&#10;        processed |= {vertex_to}&#10;        q[:0] = [vertex_to]&#10;        print(f&quot; bfs process {vertex_from}-{vertex_to}&quot;)&#10;        work(vertex_from, vertex_to)&#10;&#10;    print(&quot;start verticle not processed=&quot;, start_vertex)&#10;    process(start_vertex, start_vertex) # ! no edge when start&#10;    while q:&#10;        v = q.pop()&#10;        for e in graph[v]:&#10;            process(v, e)&#10;&#10;    return processed&#10;&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_,result)&#10;&#10;&#10;main_$bfs$()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fun graph  undirected DRAW with labels" value="import networkx as nx&#10;import matplotlib.pyplot as plt&#10;&#10;&#10;def draw_graph(graph,labels_ =None):&#10;    &quot;&quot;&quot;graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&quot;&quot;&quot;&#10;    if not labels_: labels_ = {}&#10;&#10;    g = nx.DiGraph()&#10;&#10;    for v in graph:&#10;        g.add_node(v)&#10;        label_additional=labels_.get(v, &quot;&quot;);&#10;        labels_[v]= f&quot;{v}  ={label_additional}&quot;&#10;        for e in graph[v]:&#10;            g.add_edge(v, e)&#10;&#10;    pos = nx.spring_layout(g)&#10;    nx.draw_networkx_nodes(g, pos)&#10;&#10;&#10;    nx.draw_networkx_labels(g, pos,labels=labels_)&#10;    # nx.draw_networkx_edge_labels(g, pos)&#10;    nx.draw_networkx_edges(g, pos, edge_color='r', arrows=True)&#10;    plt.show()" description="BFS breadth first search algo" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER DFS" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;&#10;def $bfs$(graph, start_vertex=None, work=None, processed=None):&#10;    &quot;&quot;&quot; $bfs$ return processed elements &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2: return []&#10;&#10;    if not work: work = lambda x:None&#10;    if not start_vertex: start_vertex_ = next(iter(graph))&#10;    if not processed: processed = set()&#10;&#10;    q = []&#10;&#10;    def is_process(vertex):&#10;        nonlocal processed&#10;        if vertex in processed: return False&#10;        processed |= {vertex}&#10;        return True&#10;&#10;    def will_process(vertex):&#10;        nonlocal q&#10;        q += [vertex]&#10;&#10;    print(&quot;start form=&quot;, start_vertex)&#10;    will_process(start_vertex)&#10;    while q:&#10;        v = q.pop()&#10;        if not is_process(v): continue&#10;        for e in graph[v]:&#10;            will_process(e)&#10;        print(f&quot;dfs process v={v}&quot;)&#10;        work(v)&#10;&#10;    return processed&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    input_=graph_directed&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_,result)&#10;&#10;&#10;main_$bfs$()" description="DFS depth first search algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  SUPER topological sort" value="##############################################################################################################################################################&#10;################# $bfs$ #####################################################################################################################################&#10;##############################################################################################################################################################&#10;&#10;def $bfs$(graph):&#10;    &quot;&quot;&quot; $bfs$ return verticies in the topological order &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    s, processed, inputs, result = [], set(), {v:0 for v in graph}, []&#10;&#10;    # find for all vertices num of inputs edges&#10;    for v in graph:&#10;        for e in graph[v]:&#10;            inputs[e] += 1&#10;&#10;    # start verticis with 0-input edges (or min fo cycled graphs)&#10;    min_ = min(inputs.values())&#10;    inputs = {k:v - min_ for k, v in inputs.items()}&#10;    &#10;    s += [v for v, i in inputs.items() if i &lt;= 0]&#10;    print(&quot;start form=&quot;, s)&#10;    &#10;    while s:&#10;        v = s.pop()&#10;        for e in graph[v]:&#10;            inputs[e] -= 1&#10;            if not inputs[e]:&#10;                s += [e]&#10;        print(f&quot;ts process v={v}&quot;)&#10;        result += [v]&#10;&#10;    return result&#10;    &#10;&#10;&#10;def main_$bfs$():&#10;    graph_undirected = {&#10;        1:[2, 3],&#10;        2:[1, 3, 4],&#10;        3:[1, 2, 4],&#10;        4:[2, 3]}&#10;&#10;    graph_directed = {&#10;        1:[2, 3],&#10;        2:[3, 4],&#10;        3:[4],&#10;        4:[]}&#10;        &#10;    graph_unconnected = {&#10;        1:[3, 5],&#10;        2:[4],&#10;        3:[5],&#10;        4:[],&#10;        5:[7, 9],&#10;        6:[8, 10],&#10;        7:[],&#10;        8:[],&#10;        9:[],&#10;        10:[]}&#10;&#10;    graph_toposort = {&#10;        4:[],&#10;        3:[4],&#10;        2:[4],&#10;        1:[2, 3]}&#10;&#10;    input_ = graph_toposort&#10;    result=$bfs$(input_)&#10;    print(&quot;MAIN $bfs$: &quot;, result)&#10;    draw_graph(input_,result)&#10;&#10;&#10;main_$bfs$()" description="TS   algo" toReformat="false" toShortenFQNames="true">
    <variable name="bfs" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  shortest paths" value="def shortest_path2(graph):&#10;    &quot;&quot;&quot; shortest_path &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    lens = {v:inf for v in graph}&#10;    start_vertex, lens[start_vertex] = 1, 0&#10;    add_len = lambda x, y:lens.__setitem__(y, lens[x] + 1)&#10;    # debug_len = lambda y, x:print(&quot;debug&quot;, x, y)&#10;    bfs(graph, start_vertex, add_len)&#10;&#10;    return lens&#10;&#10; " description="lens of verticies" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="function GRAPHundirected  weak connected conponents" value="def undirected_connected_components2(graph):&#10;    &quot;&quot;&quot; undirected_connected_components &quot;&quot;&quot;&#10;    if not graph: warn(&quot;Input argument is empty&quot;, UserWarning)&#10;    assert isinstance(graph, dict)&#10;    l = len(graph)&#10;    if l &lt; 2:  return {}&#10;&#10;    processed, connectings, counter = set(), {}, 0&#10;    set_counter = lambda x, y:connectings.__setitem__(y, counter)&#10;&#10;    for w in graph:&#10;        if w in processed: continue&#10;        counter += 1&#10;        processed |= bfs(graph, w, set_counter, processed)&#10;        print(&quot;PROCESSED=&quot;, processed)&#10;&#10;    return connectings&#10;&#10; " description="lens of verticies" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
</templateSet>